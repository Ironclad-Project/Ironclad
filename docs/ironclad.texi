\input texinfo
@setfilename ironclad.info
@documentencoding UTF-8
@settitle Ironclad User's Guide

@copying
Copyright @copyright{} 2025 streaksu

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
copy of the license is included in the section entitled ``GNU Free
Documentation License''.
@end quotation
@end copying

@titlepage
@title Ironclad User's Guide
@subtitle Userland interfaces and devices, features, and kernel internals.
@author streaksu
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage
@contents

@ifnottex
@node Top
@top Ironclad User's Guide

This manual documents usage of Ironclad, interfaces and devices it exposes to
userland, and discusses kernel internals, without having to navigate the often
cryptic and scary Ada code.

@insertcopying
@end ifnottex

@menu
* Installation and target support::    Installation and hardware support.
* Boot-time command-line options::     Command-line options.
* Scheduling and RTC::                 Scheduling methodology and features.
* Inter-process communication::        IPC primitives, methods, and quirks.
* Memory architecture::                Memory architecture of the kernel.
* Userland state and conditions::      Userland state and conditions.
* Security and integrity facilities::  Ironclad-specific security facilities.
* Debugging facilities::               Ironclad-specific debugging facilities.
* Syscalls::                           Listings and explanation of syscalls.
* Networking::                         Networking support and details.
* Virtualization::                     VM virtualization inside Ironclad.
* Filesystem support and interfaces::  VFS details and supported filesystems.
* Devices and their properties::       Devices exposed by the kernel.
* GNU Free Documentation License::     Copying and sharing this manual.

@detailmenu
--- The Detailed Node Listing ---

Installation and target support

* riscv64-limine support::     riscv64-limine installation and support.
* x86_64-limine support::      x86_64-limine installation and support.

Boot-time command-line options

* Format::                 Description of the format.
* List::                   List of all the available command line arguments.

Scheduling and RTC

* Ticks and other interruptions::  Thread interruptions to expect.
* Scheduling algorithms::          Scheduling models used in Ironclad.

Inter-process communication

* Pipes::                      FIFOs (yay!).
* Futexes::                    Fast-Userspace MuTeXes.
* PTYs::                       Pseudo-terminal creation and management.
* Signals::                    Ironclad's signal mechanism.
* Sockets::                    Sockets in all of its glory and flavours.

Memory architecture

* Physical memory allocation::  How the kernel goes about allocating memory.
* Virtual memory::              Virtual memory architecture.
* Memory failures::             Memory failure policies and conditions.

Userland state and conditions

* Program loading::    Format of the loaded programs.
* Memory layout::      Layout of memory in userland.
* Auxiliary vectors::  Auxiliary values passed to programs.

Security and integrity facilities

* Users and groups::                UIDs, EUIDs, GIDs, and all the fuzz.
* Mandatory access control (MAC)::  MAC quickguide and configuration.
* Resource limits::                 Limits on resources built into MAC.
* Miscellaneous measures::          Miscellaneous security measures.

Debugging facilities

* Corefile and process dumping::      Format of dumped files, and settings.
* Program tracing::                   Details on program tracing.

Syscalls

* Table and target quirks:: Syscall table and architectural ABI.
* Errno::                   Error conditions and their values.
* exit::                    Exit the callee process.
* arch_prctl::              Interacting with architectural thread-local data.
* open::                    Opening file-system entities.
* close::                   Closing file descriptors.
* read/write::              Read and write from file descriptors.
* seek::                    Modify and fetch file offsets.
* mmap/mprotect/munmap::    Manage memory regions.
* getpid/getppid::          Get the PIDs of the caller.
* exec::                    Launching new programs.
* fork::                    Create new processes.
* wait::                    Waiting for execution of a child to finish.
* socket::                  Create sockets.
* sethostname::             Hostname setting.
* unlink::                  Queue files for deletion.
* fstat::                   Fetch file information.
* pivot_root::              Pivot the root mountpoint.
* chdir::                   Current working directory manipulation.
* ioctl::                   IO multiplexer.
* sched_yield::             Relinquish CPU time.
* pipe::                    Create pipes.
* rename::                  Rename a file.
* listprocs::               List system processes.
* gettid::                  Get the current thread id.
* fcntl::                   Multiplexed operations for files.
* exit_thread::             Exit the calling thread.
* getentropy::              Bypass /dev/random for avoiding DoS attacks.
* mac_capabilities::        Get and set MAC capabilities.
* add_mac_permissions::     Configure MAC using filesystem-based filters.
* set_mac_enforcement::     Set enforcement to follow on MAC violations.
* mount/umount::            Mount and unmount partitions.
* readlink::                Read the contents of a symlink.
* getdents::                Get directory entries.
* sync::                    Synchronize device caches.
* mknod::                   Create several kinds of files.
* truncate::                Truncate the contents of a file to an offset.
* bind::                    Bind sockets to locations.
* mkdir::                   Create directories.
* symlink::                 Create symbolic links.
* connect::                 Connect a socket.
* openpty::                 Create pseudoterminals.
* fsync::                   Synchronize file-specific caches.
* link::                    Create hard links.
* ptrace::                  Trace and debug children processes.
* listen::                  Listen for connections to a socket.
* accept::                  Accept socket connections.
* rlimit::                  Get and set resource limits.
* sched_rr_interval::       Get and set SCHED_RR intervals.
* access::                  Check file access permissions and existence.
* ppoll::                   I/O event multiplexer.
* getuid/geteuid::          Get the UID and the effective UID.
* setuids::                 Set the UID and the effective UID.
* fchmod::                  Change the mode of a file descriptor.
* umask::                   Get and set the calling process umask.
* reboot::                  Machine power management.
* fchown::                  Change ownership of a file descriptor.
* getpgid/setpgid::         Get or set the process group of a PID.
* getsid/setsid::           Get or set the session ID of a process.
* getsockname::             Get address of a bound socket.
* getpeername::             Get address of a socket's peer.
* shutdown::                Disconnect socket from its peer.
* futex::                   Fast userland mutexes.
* clock::                   Clock and time operations.
* clock_nanosleep::         Sleep on a clock.
* getrusage::               Get resource usage for the process.
* recvfrom/sendto::         Socket IO support functions.
* config_netinter::         Configure network interfaces.
* utimes::                  Modify timestamps for a file.
* get/set_scheduler::       Get and set scheduling details for a process.
* get_min/max_priority::    Get the minimum and maximum scheduler priority.
* sigprogmask::             Fetch and change a process' blocked signal.
* sigaction::               Fetch and change a signal's action.
* send_signal::             Send a signal to a process.
* getprio/setprio::         Get / Set the niceness of some entities.
* getgid/getegid::          Get the GID and the effective GID.
* setgids::                 Set the GID and the effective GID.
* getgroups/setgroups::     Get and set supplementary user groups.
* ttyname::                 Get the name of a TTY file descriptor.
* fadvise::                 Advise caching for file access.
* shmat::                   Attach a shared memory region.
* shmctl::                  Control a shared memory region.
* shmdl::                   Delete a shared memory region.
* shmget::                  Create or get a shared memory region by key.
* getsockopt/setsockopt::   Get and set options on sockets.
* gettidid/settidid::       Get and set TID IDs.
* failure_policy::          Get or set failure policies.
* create_thread::           Create new processes.
* signal_return::           Return from a signal body.
* sigaltstack::             Set alternative stacks for signal handling.
* recvsockctr/sendsockctr:: Send and receive control blocks.
* listmounts::              List the system's mounts.
* uname::                   List system information.
* listthreads::             List the system's threads.
* listnetinter::            List the system's network interfaces.
* dumplogs::                List the system's kernel logs.
* listflocks::              List the system's file locks.
* loadavg::                 List load averages of the system.
* meminfo::                 List the system's memory configuration.
* listpci::                 List the system's PCI devices.
* getcpuinfo::              List system CPU information.
* socketpair::              Comfortably create a pair of pipe-like sockets.
* madvise::                 Give optimization hints for memory ranges.
* nvmm_capability::         Check NVMM system capabilities.
* nvmm_machine_create::     Create an NVMM virtual machine.
* nvmm_machine_destroy::    Destroy an aforementioned VM.
* nvmm_machine_configure::  Configure an aforementioned VM.
* nvmm_vcpu_create::        Create an NVMM VCPU.
* nvmm_vcpu_destroy::       Destroy an aforementioned VM.
* nvmm_vcpu_configure::     Configure an aforementioned VM.
* nvmm_vcpu_setstate::      Get VCPU state.
* nvmm_vcpu_getstate::      Set VCPU state.
* nvmm_vcpu_inject::        Inject code for a VCPU.
* nvmm_vcpu_run::           Issue a VCPU for running.
* nvmm_gpa_map::            Map a GPA.
* nvmm_gpa_unmap::          Unmap a GPA.
* nvmm_hva_map::            Map a HVA.
* nvmm_hva_unmap::          Unmap a HVA.
* nvmm_gva_2_gpa::          Map a GVA to a GPA.
* nvmm_gpa_2_hva::          Map a GPA to a HVA.
* nvmm_assist_io::          Assist NVMM machines at IO operations.
* nvmm_assist_mem::         Assist NVMM machines at memory operations.
* nvmm_vcpu_dump::          Dump VCPU state.
* nvmm_vcpu_stop::          Stop a VCPU.
* pci_read/pci_write::      PCI device read/write.

Networking

* Layering::             What Ironclad provides in terms of the OSI model.
* Interface handling::   How interfaces work inside Ironclad.
* Loopback::             Loopback device use and specification.

Virtualization

* NetBSD Virtual Machine Monitor (NVMM)::  Details about NVMM.
* Differences with NetBSD::                Specification of Ironclad's NVMM.

Filesystem support and interfaces

* Generic filesystem options::   Elements common to all filesystems.
* EXTended filesystem (EXT)::    EXT-series filesystems (ext2, ext3, ext4).
* File Allocation Table (FAT)::  FAT-series filesystems.

Devices and their properties

* Common devices::             Devices common to all architectures and targets.
* riscv64-limine devices::     Devices specific to riscv64-limine.
* x86_64-limine devices::      Devices specific to x86_64-limine.

@end detailmenu
@end menu

@node Installation and target support
@chapter Installation and target support

This chapter delves on what hardware configurations Ironclad supports and how
to get Ironclad running on those platforms.

Ironclad hardware support is divided in targets, which are combos of
an architecture and board that are supported in tandem, along with any
accompaning hardware, some hardware is supported regardless of the underlying
target, @ref{Common devices}.

@node riscv64-limine support
@section riscv64-limine support

Ironclad supports RISC-V64 systems supporting the IMAC, ZICSR, D, and ZIFENCEI
extensions.

A Limine protocol-compatible bootloader compliant is required, our
recommendation is @uref{https://limine-bootloader.org, Limine}, as it is the
only available for RISC-V64 right now. Refer to your bootloader for
instructions on where to put kernel images, configuration formats, and the
like.

SBI support is required for Ironclad to properly work, other facilities like
ACPI are optional.

For an example of RISC-V based deployment, check the boot sequence of
@uref{https://codeberg.org/Ironclad/Gloire, Gloire}, a FOSS Ironclad
distribution.

@node x86_64-limine support
@section x86_64-limine support

Generic x86_64 systems are supported using the limine boot protocol, any
limine compliant bootloader will be able to boot it just fine. Options exist
for UEFI and BIOS, our recommendation is
@uref{https://limine-bootloader.org, Limine}, which supports both.

No requirements for specific SIMD extensions are made apart from what
x86_64 features architecturally.

@node Boot-time command-line options
@chapter Boot-time command-line options

Ironclad takes, as part of its boot protocol, a series of options and values.
The parsing of this options is architecture and platform independent, while the
ability to modify said options and values is entirely up to the platform and
bootloader.

@node Format
@section Format

The format is a list of keys with optional arguments as such:

@example shellscript
key1=value1 key2 key3=value3 key4="value4 value5" ... keyN=(")valueN(")
@end example

For arguments that need spaces within, like init program arguments and such,
quotation marks are available for use, nested quotation marks are not allowed
in any shape or form, due to the primitive parsing available within the kernel.

@node List
@section List

This are the keys and values the kernel takes, and under which circumstances:

@table @code
@item root=<device>
Device to mount as root, if any.

@item rootuuid=<uuid>
Used instead of @code{root}. It addresses the root device with a UUID instead
of a device name. This can be used to gain some device-independence, for
example, for addressing a given partition in a GPT drive regardless the
containing device.

@item init=<path>
Path to a program that will be booted by the kernel when finished loading.
The program will be started with @code{stdin} set to @code{/dev/null}, and
@code{stdout} and @code{stderr} set to @code{/dev/console}.

@item initargs=<args>
Arguments to pass to init. If environment variables are what is desired,
consider the trick of booting in typical UNIX fashion
@code{/bin/env <vars> <init command>}.

@item noprogaslr
The offset of loaded programs in virtual memory is randomized when loading if
possible, this option disables it system-wide at boot time and hardcodes it to
the lowest available value.

@item nolocaslr
The same as @code{noprogaslr} but applied to memory locations like stacks
and memory allocation.
@end table

@node Scheduling and RTC
@chapter Scheduling and RTC

Ironclad is built around hard real-time work, this chapter explains how that
is accomplished along with how scheduling works, predictability of it, and
other useful related features.

@node Ticks and other interruptions
@section Ticks and other interruptions

Ironclad will not interrupt a running thread for timers or heartbeats, if
necessary, at the expense of performance by, for example, using polling instead
of interrupt-based operation for device drivers.

A thread, however, may be interrupted for task-switching, which is needed for
scheduling to work. This will not be an issue for most operations, but if the
user desires absolutely 0 interruptions and/or jitter, one can use

@node Scheduling algorithms
@section Scheduling algorithms

Ironclad provides several schedulers that individual processes can set for
use using the @pxref{get/set_scheduler} syscalls.

Four schedulers are provided, two of them Real Time (RT) capable, two of them
non-RT.

The non-RT ones are:
@table @code
@item SCHED_OTHER
Default scheduling algorithm for every process created before being moved to a
specific policy. The operating system reserves the right to change the
algorithm used for this option, thus, users should not rely on any specifics
about it.

@item SCHED_IDLE
For use with largely inactive processes (like daemons, or services). Just like
@code{SCHED_OTHER}, we reserve the right to change the specifics.
@end table

The RT ones are:
@table @code
@item SCHED_FIFO
The process will run in a first-in-first-out basis. Instead of niceness, this
policy uses priority, governed by the @code{sched_param} argument of
@code{set_scheduler}. Processes will be run until completion. To then go to the
next available RT process with higher priority, or, if none available,
non-RT tasks.

@item SCHED_RR
Similar to @code{SCHED_FIFO}. Processes of equal priority will be run in a
round-robin fashion until time is freed by completion or explicit yielding or
sleeping.
@end table

All RT policies have implicitly higher priority than non-RT ones, meaning that
the OS will interrupt other tasks in order to fulfill the requirements of RT
tasks regardless of other factors, like system responsibity or stability. Thus,
be sure you know what you are doing when using RT policies!

The range of priorities accepted by @code{sched_param} is comprised of the
range between @code{get_min_priority} and @code{get_max_priority}.
@pxref{get_min/max_priority}.

@node Inter-process communication
@chapter Inter-process communication

This chapter digs into the forms of IPC Ironclad supports, what they do, and
how they can help accomplish complex local or remote IPC.

@node Pipes
@section Pipes

Ironclad features standard POSIX-like pipes, they are created using
@pxref{pipe}.

The standard size of pipes is 10 architectural pages. This size can be modified
using the following @code{fcntl} calls.

@example c
#define F_GETPIPE_SZ 7     // Get the size in bytes.
#define F_SETPIPE_SZ 8     // Set the size in bytes.
@end example

@node Futexes
@section Futexes

Standard Linux-like futexes. @ref{futex}.

@node PTYs
@section PTYs

Pseudo terminals (PTYs) are available in Ironclad, They are created using
@pxref{openpty}. Ironclad does not provide a @code{/dev/ptmx} like interface.

PTYs populate @code{/dev} with names of the form @code{/dev/ptyX}, where X is
a positive integer. PTYs are closed automatically when they are closed.

PTYs react to a limited amount of termios flags, most of them left to userland.
The ones Ironclad PTYs interact with are @code{OPOST} and @code{ONLCR}.

@node Signals
@section Signals

Ironclad implements standard POSIX signals for use between processes. The
supported signals with their corresponding values are:

@enumerate 1
@item SIGHUP
@item SIGINT
@item SIGQUIT
@item SIGCONT
@item SIGBUS
@item SIGABRT
@item SIGCHLD
@item SIGFPE
@item SIGKILL
@item SIGILL
@item SIGPIPE
@item SIGSEGV
@item SIGSTOP
@item SIGALRM
@item SIGTERM
@item SIGTSTP
@item SIGTTIN
@item SIGTTOU
@item SIGUSR1
@item SIGUSR2
@item SIGPOLL
@item SIGPROF
@item SIGSYS
@item SIGTRAP
@item SIGURG
@item SIGVTALRM
@item SIGXCPU
@item SIGXFSZ
@item SIGWINCH
@item SIGPWR
@end enumerate

A Linux-like signal model is provided, where the kernel takes care of signal
dispatching and registering, and the only thing userland has to do in
particular to support signal control flow transfer is using @code{sa_restorer}
and @code{signal_return} syscalls, in a construct as such:

@example c
void restorer(void) @{
    // Do whatever on signal end.
    signal_return();
    // Handle error, usually just panic.
    __builtin_unreachable();
@}
@end example

In a normal desktop system, this will be implemented by the libc or similar
layer, but this is something to keep in mind when working without those
abstractions. @ref{sigaction}, @ref{signal_return}.

@node Sockets
@section Sockets

Standard sockets. @ref{socket}.

@node Memory architecture
@chapter Memory architecture

This section delves into details on Ironclad's memory management.

@node Physical memory allocation
@section Physical memory allocation

Ironclad features two physical memory allocator choices for use, the chosen
allocator will be used both for kernel and userland allocations, the standard
and alloconly allocators.

The standard allocator is a general purpose allocator for your average
everyday allocator needs. Its internally implemented as a bitmap allocator with
page-sized blocks and a quick cache for small objects, along with some quick
hardening features, like checksums.

The alloconly option features several optimizations on top of the usual
allocator in order to save memory and tune operation, for usecases where nor
userland nor the kernel are wanted to deallocate memory at all.

@node Virtual memory
@section Virtual memory

The virtual memory architecture of Ironclad is quite simple, given the need
to avoid things like complex virtual memory management which could influence
predictability with page-related interrupts, and similar features. For the same
reason, memory overcommiting is not allowed.

@node Memory failures
@section Memory failures

When facing an OOM condition caused by userland-born allocations, Ironclad will
just fail the syscalls issuing them.

When facing OOM conditions caused by kernel-born allocations, the kernel will
panic. Process killing is the only alternative, which due to complexity,
inherent non-determinism, and rarity of the scenario when compared with
userland-born failures, the kernel does not implement.

For hardware failures, behaviour can be configured at @ref{failure_policy}.

@node Userland state and conditions
@chapter Userland state and conditions

Ironclad places several requirements on loaded userland programs, from the
format of which, to memory layout.

@node Program loading
@section Program loading

Loaded programs must be under the ELF64 format, other formats may be supported
in the future. Loaded programs can be static or relocatable.

When loading a static executable, no sections of the executable will be loaded
below 2M in memory. This is done as to ensure NULL remains unmapped.

@code{ld.so}, or any other linker program detailed on the interpreter segment
of the ELF executable will be a special case, it is assumed to be relocatable.

@node Memory layout
@section Memory layout

Loaded programs are loaded at address 0, and they are free to allocate
themselves at nearby offsets.

@code{ld.so} and entities like stacks, anonymous memory regions, and others,
will be randomized on load time following
@uref{https://en.wikipedia.org/wiki/Address_space_layout_randomization, ASLR},
and must not be relied upon. It is up to @code{ld.so} to optionally place
additionally loaded libraries at random offsets.

The stack is a fixed @code{128 KiB} in size, and is not executable, by default.

@node Auxiliary vectors
@section Auxiliary vectors

Ironclad supports passing auxiliary vectors to the started processes. Auxiliary
vectors are tags of data passed on the stack to programs detailing additional
data. These values are passed behind @code{envp}.

Each vector consists of a pair of values: an identifier, and a 64-bit integer.

The vectors passed by the kernel by value are:

@table @code
@item AT_NULL (0)
Signifies the end of the vector chain.

@item AT_PHDR (3)
The address of the program headers of the executable.

@item AT_PHENT (4)
The size of program header entry.

@item AT_PHNUM (5)
The number of program headers.

@item AT_PAGESZ (6)
Minimum MMU page size of the system.

@item AT_ENTRY (9)
The entrypoint of the executable.

@item AT_SECURE (23)
The value will be 1 if the executable is to be treated securely, 0 if not.
This flag will be set by Ironclad when the program holds the
@code{MAC_CAP_SCHED} capability.
@end table

@node Security and integrity facilities
@chapter Security and integrity facilities

This chapter digs into the various Ironclad-specific security and integrity
features available for the user.

@node Users and groups
@section Users and groups

As part of the UNIX-like package, Ironclad supports the traditional UID/EUID
values per-process for basic access protection, both for files and syscalls.

Unlike most UNIX systems, the @code{setuid} bit is fully ignored and not
implemented, instead, as part of the mandatory access control facilities
explained later, @code{MAC_CAP_SETUID} is provided, with similar functionality.

Groups are not supported in any shape or form.

@node Mandatory access control (MAC)
@section Mandatory access control (MAC)

Mandatory access control (MAC) is one of the main components of Ironclad's
security. It does not necessarily help with preventing breaches, but, when
configured correctly, it can help mitigate consequences to a massive degree.

MAC in Ironclad consists on a series of settings inherited from parent process
to children, these settings come in the form of capabilities and file filters.

Capabilities are a set of coarse permissions that restrict a process on what it
can and cannot do, only more restrictive capability escalations are allowed,
they are configured using @ref{mac_capabilities}.

The available capability list is:

@table @code
@item MAC_CAP_SCHED
The process will be allowed to change its own scheduling rules, like modifying
deadlines.

@item MAC_CAP_SPAWN
The process will be allowed to spawn other processes and threads.

@item MAC_CAP_ENTROPY
The process will have unrestricted access to the sources of entropy of the
kernel, this does not cover the UNIX-standard @code{random/urandom}.

@item MAC_CAP_SYS_MEM
The process will be able to allocate and deallocate both private and shared
memory regions.

@item MAC_CAP_USE_NET
The process will be able to use networking.

@item MAC_CAP_SYS_NET
The process will be able to modify networking, for things like hostname
changing.

@item MAC_CAP_SYS_MNT
The process will be able to modify, add, and remove mountpoints.

@item MAC_CAP_SYS_PWR
The process will be able to modify power settings, along doing things like
shutdown and reboot.

@item MAC_CAP_PTRACE
The process will be able to use ptrace on children processes.

@item MAC_CAP_SETUID
The process will be able to change its effective and global UIDs without
checks.

@item MAC_CAP_SYS_MAC
The process will be able to add allowed inodes to the MAC definitions, along
with modifying hard limits for system resources.

@item MAC_CAP_CLOCK
The process will be able to access clocks syscalls like @ref{clock} or
@code{clock_nanosleep}, as well as setting the time of clocks that can do so.
This is provided as reading clock time can sometimes be used as a way to
coordinate attacks.

@item MAC_CAP_SIGNALALL
Processes by default need to share the user with another one to either kill it
or send a signal. This capability allows to send signals to all processes,
regardless of the user issuing it.

@item MAC_CAP_SETGID
The process will be able to change its effective and global UIDs without
checks.

@item MAC_CAP_IPC
The process will be able to bypass UID/GID and mode checks when interacting
with SystemV-style IPC objects, like the ones you can create with @ref{shmget}.

@item MAC_CAP_SYS_LOG
The process will be able to access system logs, like the kernel's dmesg.
@end table

File filters consist on permissions given to specific paths and files, that,
just like capabilities, get inherited from parent to child processes.
Access to inodes and devices can be granted using @ref{add_mac_permissions}.

The action to take on MAC violations can be set with @ref{set_mac_enforcement}.
Possible values include denying requests, killing the offending part outright,
or denying and additionally logging the event.

Once booted, MAC is enabled and gives full access to all capabilities, and
offers full access to all inodes and devices. It is up to userland to further
restrict access, and for those settings to trickle down to children processes.
File access enforcement will kick in only once the first filter is added with
@ref{add_mac_permissions}.

@node Resource limits
@section Resource limits

As part of the UNIX-like package, Ironclad supports various resource limits
that, in the case of Ironclad, are built inside MAC, and are passed down like
MAC capabilities (@pxref{Mandatory access control (MAC)}). @xref{rlimit}.

Limits mostly act as you would expect them to behave, and they are all
initialized to the maximum possible value, there are only 2 quirks: For one,
limits are only deescalatory (like MAC), you can only go down, never up, and,
since Ironclad does not support dynamically growing stacks, the initial size is
dictated (for the stacks created by the kernel) with @code{RLIMIT_STACK}. Thus,
Ironclad does not start that limit with the maximum value, but a smaller valid
size.

A short description of the available limits and their default values is:

@table @code
@item RLIMIT_CORE
Size of corefile dumps, by default 0 (disabling it).

@item RLIMIT_CPU
Limit of CPU time a process can consume in seconds, by default -1 (max value).

@item RLIMIT_FSIZE
Limit of individual file size a process can write, by default -1 (max value).

@item RLIMIT_NOFILE
Limit of files a process can open on top of other system limits, by default
-1 (max value).

@item RLIMIT_STACK
Limit of stack size for a process, by default 4 MiB.

@item RLIMIT_AS
Limit of maximum address size space used by a process, by default
-1 (max value).
@end table

@node Miscellaneous measures
@section Miscellaneous measures

@subsection W^X

Ironclad does not allow mapping memory sections write and execute at the same
time, this helps mitigate several kinds of memory corruption vulnerabilities
by making it much harder to transform them into arbitrary code execution.

@node Debugging facilities
@chapter Debugging facilities

This chapter digs into the various Ironclad-specific debugging features
available for the user.

@node Corefile and process dumping
@section Corefile and process dumping

Ironclad implements corefile dumping when a process irreparably crashes, which
can be controlled and entirely disabled if wanted with the related limits, see
@ref{Resource limits}.

Corefiles are generated on a path created as:

@example
/tmp/<faulting PID>.core
@end example

This path is not configurable, and will only be created and overwritten if the
file des not exist already.

As seen in @ref{Resource limits}, corefiles are disabled by default, this is
done since core files can potentially contain private, sensible information
that could be exploited by an attacker.

The format is a register dump of the process.

@node Program tracing
@section Program tracing

Ironclad allows tracing children processes for a variety of information, MAC
willing, see @ref{ptrace}.

@node Syscalls
@chapter Syscalls

Syscall are the main method for userland to interface with the kernel's
facilities, this section delves into the mechanism and how it works.

@node Table and target quirks
@section Table and target quirks

Syscalls in Ironclad have an architecture-dependent ABI, but the table and its
indexes are always the same, this is done to simplify development. and here is a list of the
supported architectures and the ABI for each of them. Here is the table:

@enumerate 0
@item
@ref{exit}.
@item
@ref{arch_prctl}.
@item
@ref{open}.
@item
@ref{close}.
@item
@ref{read/write, read}.
@item
@ref{read/write, write}.
@item
@ref{seek}.
@item
@ref{mmap/mprotect/munmap, mmap}.
@item
@ref{mmap/mprotect/munmap, munmap}.
@item
@ref{getpid/getppid, getpid}.
@item
@ref{getpid/getppid, getppid}.
@item
@ref{exec}.
@item
@ref{fork}.
@item
@ref{wait}.
@item
@ref{socket}.
@item
@ref{sethostname}.
@item
@ref{unlink}.
@item
@ref{fstat}.
@item
@ref{pivot_root}.
@item
@ref{chdir}.
@item
@ref{ioctl}.
@item
@ref{sched_yield}.
@item
@ref{get_min/max_priority, get_min_priority}.
@item
@ref{pipe}.
@item
@ref{getuid/geteuid, getuid}.
@item
@ref{rename}.
@item
@ref{listprocs}.
@item
@ref{getsid/setsid, getsid}.
@item
@ref{gettid}.
@item
@ref{get_min/max_priority, get_max_priority}.
@item
@ref{fcntl}.
@item
@ref{exit_thread}.
@item
@ref{getentropy}.
@item
@ref{mmap/mprotect/munmap, mprotect}.
@item
@ref{sync}.
@item
@ref{mac_capabilities, set_mac_capabilities}.
@item
@ref{mac_capabilities, get_mac_capabilities}.
@item
@ref{add_mac_permissions}.
@item
@ref{set_mac_enforcement}.
@item
@ref{mount/umount, mount}.
@item
@ref{mount/umount, umount}.
@item
@ref{readlink}.
@item
@ref{getdents}.
@item
@ref{mknod}.
@item
@ref{truncate}.
@item
@ref{bind}.
@item
@ref{symlink}.
@item
@ref{connect}.
@item
@ref{openpty}.
@item
@ref{fsync}.
@item
@ref{link}.
@item
@ref{ptrace}.
@item
@ref{listen}.
@item
@ref{accept}.
@item
@ref{rlimit}.
@item
@ref{sched_rr_interval}.
@item
@ref{access}.
@item
@ref{ppoll}.
@item
@ref{getuid/geteuid, geteuid}.
@item
@ref{setuids}.
@item
@ref{fchmod}.
@item
@ref{umask}.
@item
@ref{reboot}.
@item
@ref{fchown}.
@item
@ref{getpgid/setpgid, getpgid}.
@item
@ref{getpgid/setpgid, setpgid}.
@item
@ref{getsockname}.
@item
@ref{getpeername}.
@item
@ref{shutdown}.
@item
@ref{futex}.
@item
@ref{clock}.
@item
@ref{clock_nanosleep}.
@item
@ref{getrusage}.
@item
@ref{recvfrom/sendto, recvfrom}.
@item
@ref{recvfrom/sendto, sendto}.
@item
@ref{config_netinter}.
@item
@ref{utimes}.
@item
@ref{get/set_scheduler, get_scheduler}.
@item
@ref{get/set_scheduler, set_scheduler}.
@item
@ref{sigprogmask}.
@item
@ref{sigaction}.
@item
@ref{send_signal}.
@item
@ref{getprio/setprio, getprio}.
@item
@ref{getprio/setprio, setprio}.
@item
@ref{getgid/getegid, getgid}.
@item
@ref{getgid/getegid, getegid}.
@item
@ref{setgids}.
@item
@ref{getgroups/setgroups, getgroups}.
@item
@ref{getgroups/setgroups, setgroups}.
@item
@ref{ttyname}.
@item
@ref{fadvise}.
@item
@ref{shmat}.
@item
@ref{shmctl}.
@item
@ref{shmdl}.
@item
@ref{shmget}.
@item
@ref{getsockopt/setsockopt, getsockopt}.
@item
@ref{getsockopt/setsockopt, setsockopt}.
@item
@ref{gettidid/settidid, gettidid}.
@item
@ref{gettidid/settidid, settidid}.
@item
@ref{failure_policy}.
@item
@ref{create_thread}.
@item
@ref{signal_return}.
@item
@ref{sigaltstack}.
@item
@ref{recvsockctr/sendsockctr, recvsockctr}.
@item
@ref{listmounts}
@item
@ref{uname}
@item
@ref{listthreads}
@item
@ref{recvsockctr/sendsockctr, sendsockctr}.
@item
@ref{listnetinter}
@item
@ref{dumplogs}
@item
@ref{listflocks}
@item
@ref{loadavg}
@item
@ref{meminfo}
@item
@ref{listpci}
@item
@ref{getcpuinfo}
@item
@ref{socketpair}
@item
@ref{madvise}
@item
@ref{nvmm_capability}
@item
@ref{nvmm_machine_create}
@item
@ref{nvmm_machine_destroy}
@item
@ref{nvmm_machine_configure}
@item
@ref{nvmm_vcpu_create}
@item
@ref{nvmm_vcpu_destroy}
@item
@ref{nvmm_vcpu_configure}
@item
@ref{nvmm_vcpu_setstate}
@item
@ref{nvmm_vcpu_getstate}
@item
@ref{nvmm_vcpu_inject}
@item
@ref{nvmm_vcpu_run}
@item
@ref{nvmm_gpa_map}
@item
@ref{nvmm_gpa_unmap}
@item
@ref{nvmm_hva_map}
@item
@ref{nvmm_hva_unmap}
@item
@ref{nvmm_gva_2_gpa}
@item
@ref{nvmm_gpa_2_hva}
@item
@ref{nvmm_assist_io}
@item
@ref{nvmm_assist_mem}
@item
@ref{nvmm_vcpu_dump}
@item
@ref{nvmm_vcpu_stop}
@item
@ref{getsid/setsid, setsid}.
@end enumerate

@subsection riscv64-limine

Syscalls are invoked in Ironclad by using @code{ecall}.

The index of the syscall is passed over @code{x17}, while the return value is
returned in @code{x10}, errno is returned in @code{x11}, arguments are passed
over @code{x10}, @code{x11}, @code{x12}, @code{x13}, @code{x14}, @code{x15},
and @code{x16}.

@subsection x86_64-limine

Syscalls are invoked in Ironclad by using @code{syscall}.

The index of the syscall is passed over @code{%rax}, while the return value is
returned in @code{%rax}, errno is returned on @code{%rdx}, arguments are passed
over @code{%rdi}, @code{%rsi}, @code{%rdx}, @code{%r12}, @code{%r8},
@code{%r9}, and @code{%r10}, following the SysV ABI.

@node Errno
@section Errno

Errno are values returned by the kernel to detail the nature of an error in
depth. When a syscall does not error out, it returns the value 0 on the errno
field. Here is a table of all the possible errno and its values and meaning:

@table @code
@item ERANGE (3)
The passed value was not big enough.

@item EACCES (1002)
The passed access for a variable points to bad memory.

@item EAGAIN (1006)
The requested resource is not available at the moment.

@item EBUSY (1010)
The requested resource is busy and cannot handle the request.

@item ECHILD (1012)
The passed value is not a child process.

@item EEXIST (1019)
A resource that is trying to be created already exists.

@item EFAULT (1020)
The passed value would make the program fault.

@item EFBIG (1021)
File too large, or an attempt to surpass the limit on file size was issued.

@item EIDRM (1023)
Invalid identifier.

@item EINTR (1025)
The request was interrupted by an incoming signal.

@item EINVAL (1026)
The passed value is not valid for the called syscall.

@item EIO (1027)
The requested operation failed at a device level.

@item ELOOP (1030)
Too many symlinks were encountered when resolving a requested path.

@item EMFILE (1031)
Too many files were opened by the process.

@item ENAMETOOLONG (1036)
The passed value is too big for the syscall.

@item ENOENT (1043)
No such file or directory.

@item ENOMEM (1047)
No memory space left for the asked operation.

@item ENOSPC (1050)
The issued operation was out of capacity bounds.

@item ENOSYS (1051)
The requested syscall or flag is not implemented.

@item ENOTCONN (1052)
An operation on a connected socket was issued on an unconnected one.

@item ENOTDIR (1053)
An operation only for directories was issued for a non-directory.

@item ENOTEMPTY (1054)
A non-empty directory was attempted to be removed.

@item ENOTTY (1058)
The passed argument is not a TTY.

@item ENOTSUPP (1060)
The passed argument is valid, but does not implement the operation. Mostly
used for sockets and other networking elements when dealing with protocols.

@item EPERM (1063)
Bad permissions.

@item ESPIPE (1069)
A seek was issued to an invalid device.

@item ESRCH (1070)
The passed item could not be found after a search.

@item EBADFD (1081)
The passed FD is in a bad state or invalid.

@end table

@node exit
@section exit

@example c
void exit(uint64_t status);
@end example

This syscall terminates the calling process "immediately".
Any open file descriptors belonging to the process to be closed, and any
threads of execution are terminated. @code{SIGCHLD} will be sent to the parent
if any.

This syscall does not return any value, but it sets errno on failure:

@itemize @bullet
@item
@code{EACCES}: MAC disallowed this, rookie mistake.
@end itemize

@node arch_prctl
@section arch_prctl

@example c
int arch_prctl(int code, uint64_t argument);
@end example

This syscall interacts with architecture-specific thread-local storage. For
@code{x86_64}, these are the available codes:

@table @code
@item ARCH_SET_FS (1)
Sets @code{argument} as the current thread's FS.

@item ARCH_GET_FS (2)
Stores the current thread's FS into the variable pointed to by @code{argument}.

@item ARCH_SET_GS (3)
Sets @code{argument} as the current thread's FS.

@item ARCH_GET_GS (4)
Stores the current thread's GS into the variable pointed to by @code{argument}.
@end table

For @code{riscv64}, the architecture makes it so there is no need for this
syscall, thus, the syscall does not have valid arguments, and all arguments
will return @code{EINVAL}.

This syscall returns @code{0} on success, and @code{-1} on failure.
errno is to be set to the following values on failure:

@itemize @bullet
@item
@code{EINVAL}: @code{code} is not valid.

@item
@code{EFAULT}: @code{argument} is outside the available address space.
@end itemize

@node open
@section open

@example c
int open(int dir_fd, char *path, int path_len, int flags);
@end example

@code{open} opens the passed file relative to @code{dir_fd}, depending on the
flags passed. It does not create the file if not existent. By default, the file
descriptor will remain open across an @code{exec}.

@code{flags} can be an OR'd field of the following elements:

@table @code
@item O_RDONLY (0b0000001)
Makes the file able to be read.

@item O_WRONLY (0b0000010)
Makes the file able to be written to.

@item O_APPEND (0b0000100)
Makes the file be opened at the end of the file, instead of the beginning.

@item O_CLOEXEC (0b0001000)
Will make the file close when @code{exec}'d.

@item O_NOFOLLOW (0b0010000)
Do not follow symlinks when opening the file.

@item O_NONBLOCK (0b0100000)
Make the file not block on read or write operations when possible.

@item O_CLOFORK (0b1000000)
Will make the file close when @code{fork}'d.
@end table

If no @code{O_RDONLY} or @code{O_WRONLY} is passed, the open operation will
result in a file descriptor supporting only stat and navigating operations.

The syscall returns the opened file descriptor or @code{-1} on error, and errno
is set to the following:

@itemize @bullet
@item
@code{ENOENT}: The referenced file does not exist.

@item
@code{EINVAL}: Combination of @code{flags} is not valid.

@item
@code{EMFILE}: Too many files are already owned by the process.

@item
@code{EFAULT}: The passed path is outside the available address space.
@end itemize

@node close
@section close

@example c
int close(int fd);
@end example

@code{close} closes an open file descriptor. Once no open references exist of a
file descriptor, its resources are freed, and the file deleted if needed.

The syscall returns 0 on success and -1 in failure, and errno is set to:

@itemize @bullet
@item
@code{EBADF}: The passed file to @code{close} is not valid.
@end itemize

@node read/write
@section read/write

@example c
ssize_t read(int fd, void *buffer, size_t count, size_t offset, int flags);
ssize_t write(int fd, void *buffer, size_t count, size_t offset, int flags);
@end example

These syscalls attempts to read or write up to passed count from the passed file descriptor.

On files that support seeking, the operation commences at the file offset, and
the file offset is incremented by the number of bytes read or written. If the
file offset is at or past the end of file, no bytes are read or written, and
the operation returns zero.

@code{offset} can be used to pass an offset in conjunction with flags.

@code{flags} for now only supports being 0 or 1. If 0, it will update the
offset in file as normal, if 1, it will not update the offset, and instead of
using the local offset, will start the operation from @code{offset}, to do an
operation similar to POSIX-standard @code{pread} and @code{pwrite}.

These syscalls returns the number of bytes operated on, or @code{-1} on
failure. errno is to be set to:

@itemize @bullet
@item
@code{EBADF}: Bad file descriptor.

@item
@code{EFAULT}: The passed buffer is not accessible.

@item
@code{EINVAL}: The passed fd is not suitable for the operation.

@item
@code{EFBIG}: When writing, the issued write would surpass the process
file size limit.

@item
@code{EIO}: The requested operation failed at the device level.
@end itemize

@node seek
@section seek

@example c
off_t seek(int fd, off_t offset, int whence);
@end example

This syscall repositions the file offset of the passed file description to the
passed offset according to the directive whence as follows:

@itemize @bullet
@item
@code{SEEK_SET} (1): Set to the passed offset.

@code{SEEK_CUR} (2): Set to the current offset plus the passed offset.

@code{SEEK_END} (4): Set to the size of the file plus the passed offset.
@end itemize

This syscall returns the resulting offset, or @code{-1} on failure. errno is to
be set to:

@itemize @bullet
@item
@code{EBADF}: Bad file descriptor.

@item
@code{EINVAL}: The whence is malformed or the resulting offset would be invalid.

@item
@code{ESPIPE}: @code{seek} was called on a TTY or a pipe.
@end itemize

@node mmap/mprotect/munmap
@section mmap/mprotect/munmap

@example c
void *mmap(void *hint, size_t length, int protection, int flags, int fd,
   off_t offset);
int mprotect(void *addr, size_t len, int prot);
int munmap(void *address, size_t length);
@end example

@code{mmap} creates a new mapping in the virtual address space of the calling
process. An address can be passed, if it is @code{null}, then the kernel gets
to choose the address, else, it is taken as a hint about where to place the
mapping. If a section of the mapping overlaps an existing mapping, it will be
ignored.

@code{fd} may be used to specify a device or inode in the filesystem to back
the memory region. For devices, the mmap operation has a different meaning
for each device. For framebuffer devices, for example, one can make framebuffer
windows this way. For inodes, the contents of the file will be used to
initialize the requested memory window, starting to read from @code{offset},
filling with zeros the non-filled part, if any. This kind of filling does not
advance the reading counter of the passed device or inode.

@code{hint} and @code{length}, if not matching page boundaries for the
architecture, will be aligned by the kernel to the closest page boundaries.

@code{protection} and @code{flags} are a bitfield of the following flags:

@itemize @bullet
@item
@code{PROT_READ} (0b00001): Read permissions.

@item
@code{PROT_WRITE} (0b00010): Write permissions.

@item
@code{MAP_FIXED} (0b00100): Use hint as a hard requirement.

@item
@code{MAP_ANON} (0b01000): Mapping is not backed by any file, and @code{fd} is
ignored. Memory will be initialized to 0s.

@item
@code{MAP_WC} (0b10000): Map using write-combining when possible.
@end itemize

@code{munmap} will unmap a range for the virtual address space of the calling
process, this values must be the same as passed and returned by @code{mmap},
partial unmapping is allowed.

@code{mprotect} allows to change the permission of a range of memory of the
passed length pointed by @code{addr}, previously mapped by the caller.
The format of @code{prot} is the same as @code{mmap}.

@code{mmap} returns a pointer to the allocated area, or @code{-1} on failure.
@code{munmap} and @code{mprotect} both returns @code{0} on success and
@code{-1} on failure. All the functions set the following errno:

@itemize @bullet
@item
@code{EINVAL}: Bad hints or parameters.

@item
@code{ENOMEM}: The operation could not be completed due to a lack of memory.

@item
@code{EACCES}: MAC disallowed this.
@end itemize

@node getpid/getppid
@section getpid/getppid

@example c
int getpid();
int getppid();
@end example

@code{getpid} returns the process ID (PID) of the calling process.
@code{getppid} does the same but it returns the one of the parent, which is the
process that created the callee by a myriad of ways.

This functions are always successful.

@node exec
@section exec

@example c
int exec(const char *path, int path_len, char *const argv[], int argv_len, char *const envp[], envp_len);
@end example

This syscall executes the program passed with the passed argv and evp, closing
all the threads of the callee process and putting a single one in place for
the new program. Other process-specific elements like file descriptors are
untouched.

This syscall only returns in failure with @code{-1} with the following errno:

@itemize @bullet
@item
@code{EINVAL}: One of the passed strings or arrays is not valid.

@item
@code{ENOENT}: The file passed in path doesnt exist.

@item
@code{EACCES}: The file couldn't be launched out of a permission error.
@end itemize

@node fork
@section fork

@example c
#define FORK_VFORK 0x1

pid_t fork(int flags, int cluster);
@end example

This syscall creates a new process based on the parent process. The created
process will only have 1 thread copying the caller one, and will be placed
on the passed thread cluster.

@code{flags} is a bitmap that can be used to customize the forking operation,
the values that can be passed are:

@itemize @bullet
@item
@code{FORK_VFORK}: Instead of cloning the address space of the parent process.
The child will use the same address space until an @code{exec} is done. During
that time between @code{fork} and @code{exec}, the parent process will be
halted. Thus, both processes will never share the same address space.

This is provided for increased speed, as we can avoid copying memory just to
trash it with exec.
@end itemize

This syscall returns @code{0} on success for the child, and the new child PID
to the parent, in failure, the parent gets @code{-1} with the following errno:

@itemize @bullet
@item
@code{EAGAIN}: The system could not create the entity right now, try again
later.

@item
@code{EACCES}: MAC disallowed this.
@end itemize

@node wait
@section wait

@example c
pid_t wait(pid_t pid, int *status, int options);
@end example

This syscall suspends execution until the passed pid exits, to then store the
exit code in @code{status}.

@code{wait} allows the option @code{WNOHANG(0b000010)} for non-blocking
waiting, if the process has not finished yet, @code{0} will be returned.

@code{pid} can be one of four values:

@itemize @bullet
@item @code{Lesser than -1}: @code{pid} is taken as a process group ID.
@item @code{-1}: Wait for any child process.
@item @code{0}: Wait for any child with the same process group ID.
@item @code{Greater than 0}: @code{pid} is taken as the PID to wait on.
@end itemize

@code{pid} can be a PID the callee is a parent of, or @code{-1} to wait on all
the PIDs the callee has as children. @code{0}, which waits on all the children
of a process group, is not implemented yet.

This syscall returns the PID waited on or @code{-1} on failure, along with the
following errno:

@itemize @bullet
@item
@code{ECHILD}: The passed PID does not exist.

@item
@code{EINVAL}: The passed options are not correct or the passed PID is @code{0}
@end itemize

@node socket
@section socket

@example c
#define AF_INET   1
#define AF_INET6  2
#define AF_UNIX   3

#define SOCK_DGRAM     0b000000000000000001
#define SOCK_RAW       0b000000000000000010
#define SOCK_STREAM    0b000000000000000100
#define SOCK_SEQPACKET 0b000000000000001000
#define SOCK_NONBLOCK  0b001000000000000000
#define SOCK_CLOEXEC   0b010000000000000000
#define SOCK_CLOFORK   0b100000000000000000
int socket(int domain, int type);
@end example

This syscall for creating sockets, the passed fields can be used for selecting
the type of socket to create. The available sockets type are:

@itemize @bullet
@item
@code{AF_INET}: Basically IPv4 socket.

The address of a INET domain socket takes the shape of

@example c
struct sockaddr_in @{
   uint32_t sin_family;
   uint16_t sin_port;
   char     sin_addr[4];
   uint8_t  pad[8];
@};
@end example

@code{type} can be one of @code{SOCK_DGRAM} or @code{SOCK_STREAM}.
@code{SOCK_DGRAM} will be translated to @code{TCP}, while @code{SOCK_STREAM}
will be translated to @code{UDP}.

@item
@code{AF_INET6}: Basically IPv6 socket.

The address of a INET domain socket takes the shape of

@example c
struct sockaddr_in6 @{
   uint32_t sin6_family;
   uint16_t sin6_port;
   uint32_t sin6_flowinfo;
   char     sin6_addr[16];
   uint32_t sin6_scope_id;
@};
@end example

@code{type} can be one of @code{SOCK_DGRAM} or @code{SOCK_STREAM}.
@code{SOCK_DGRAM} will be translated to @code{TCP}, while @code{SOCK_STREAM}
will be translated to @code{UDP}.

@item
@code{AF_UNIX}: UNIX domain socket for local communication, this sockets
can be unnamed or bound to filesystem paths.

The address of a UNIX domain socket takes the shape of

@example c
struct sockaddr_un @{
   uint32_t sun_family; // AF_UNIX.
   char path[108];
@};
@end example
@end itemize

@code{type} can be one of:

@itemize @bullet
@item
@code{SOCK_DGRAM}: Unreliable, connection-less, datagram-based interface. When
used with INET protocols, it will correspond to UDP. When connected, these
sockets will just cache the address for further reception / sending.
@item
@code{SOCK_STREAM}: Reliable, connection-based stream-based interface.
Connection, accepting, and listening will be necessary for a proper handshake.
@item
@code{SOCK_RAW}: Raw communication directly with the domain layer. When using
these, no TCP or UDP will be done whatsoever, and the user will be free to
implement their own protocol on top, or none at all and just use the domain
datagram transport. Not supported for some protocols, like UNIX domain sockets.
@item
@code{SOCK_SEQPACKET}: Sequenced-packet socket that is connection-oriented,
preserves message boundaries, and delivers messages in the order that they were
sent.
@end itemize

Any socket type may have @code{type} be OR'ed with @code{SOCK_NONBLOCK} or
@code{SOCK_CLOEXEC} for setting the created socket nonblock or cloese on exec
respectively.

The syscall returns the resulting FD or @code{-1} on failure, with the
following errno:

@itemize @bullet
@item
@code{EINVAL}: Invalid combination of flags.
@item
@code{EMFILE}: No available file descriptor slots.
@end itemize

@node sethostname
@section sethostname

@example c
int sethostname(const char *buffer, size_t length);
@end example

This syscall sets the kernel hostname to the passed string. @code{0} is
returned on success and @code{-1} on failure, with the following errno:

@itemize @bullet
@item
@code{EFAULT}: The passed buffer points to an invalid address.

@item
@code{EINVAL}: The passed length is bigger than the kernel can handle or 0.

@item
@code{EACCES}: MAC did not allow this.
@end itemize

@node unlink
@section unlink

@example c
#define AT_REMOVEDIR 500

int unlink(int dir_fd, const char *path, int path_len, flags);
@end example

The syscall queues for deletion the file pointed to by @code{path}. If
@code{path} points to a directory, it will fail unless @code{AT_REMOVEDIR} is
passed in @code{flags}, in which case it will only remove it if the directory
is empty.

The syscall returns @code{0} or @code{-1} on failure, with the following errno:

@itemize @bullet
@item
@code{ENOENT}: @code{delete} points to a file not valid for deletion.
@item
@code{ENOTEMPTY}: A directory was attempted to be removed with
@code{AT_REMOVEDIR}, and it was not empty.
@item
@code{EISDIR}: A directory was passed for unlinking with no
@code{AT_REMOVEDIR}.
@end itemize

@node fstat
@section fstat

@example c
struct stat @{
    dev_t           st_dev;
    ino_t           st_ino;
    mode_t          st_mode;
    nlink_t         st_nlink;
    uid_t           st_uid;
    gid_t           st_gid;
    dev_t           st_rdev;
    off_t           st_size;
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
    struct timespec st_btim;
    blksize_t       st_blksize;
    blkcnt_t        st_blocks;
@};

int fstat(int dir_fd, char *path, int len, struct stat *buf, int flags);
@end example

This syscalls return information about a file, be it an already opened one with
@code{dir_fd} and @code{AT_EMPTY_PATH} in @code{flags}, or by relatively
opening, either following or not following symlinks with
@code{AT_SYMLINK_NOFOLLOW}.

@code{0} is returned on success, @code{-1} on failure, with the following errno:

@itemize @bullet
@item
@code{EBADF}: The passed path or file descriptor is not valid.

@item
@code{ENOENT}: The file pointed by @code{path} does not exist.

@item
@code{EFAULT}: The passed address for the path or stat buffer is not valid.
@end itemize

This syscalls return information about a file, be it an already opened one with
@code{dir_fd} and @code{AT_EMPTY_PATH} in @code{flags}, or by relatively
opening, either following or not following symlinks with
@code{AT_SYMLINK_NOFOLLOW}.

@code{0} is returned on success, @code{-1} on failure, with the following errno:

@itemize @bullet
@item
@code{EBADF}: The passed path or file descriptor is not valid.

@item
@code{ENOENT}: The file pointed by @code{path} does not exist.

@item
@code{EFAULT}: The passed address for the path or stat buffer is not valid.
@end itemize

@node pivot_root
@section pivot_root

@example c
int pivot_root(char *new_root, size_t new_len, char *old_root, size_t old_len);
@end example

This syscall pivots the root FS of the system into a new root mountpoint
mounted at @code{new_root}. @code{old_root} will be where the root mountpoint
will be moved to. The current working directory is not changed in any way. And
this change is system-wide, there is no mount namespace manipulation, unlike
Linux.

@code{old_root} can not exist inside the old root, and only exist inside
@code{new_root}.

This syscall returns 0 on success or @code{-1} on failure, with the errno:

@table @code
@item EFAULT
One of the buffers (or both) point to invalid memory.

@item EINVAL
The values passed do not point to actual mountpoints, or point to the same
mountpoint.

@item EACCES
The caller process does not have the @code{MAC_CAP_SYS_MNT} capability.
@end table

@node chdir
@section chdir

@example c
int chdir(int fd);
@end example

This syscall will set the caller's process current working directory to
the passed FD, which must point to a directory.

The syscall returns @code{0} on success and @code{-1} on failure, with the
following errno:

@itemize @bullet
@item
@code{EBADFD}: The passed descriptor is not a valid directory.
@end itemize

@node ioctl
@section ioctl

@example c
int ioctl(int fd, unsigned long request, void *argument);
@end example

This syscall manipulates the underlying device parameters of special files. It
allows a device-dependent API for fetching and setting several modes.

Despite not all ioctl calls needing a specific value for their arguments, due
to current limitations, all arguments must point to valid memory, regardless
of whether it ends up used or not.

@code{ioctl} returns @code{0} on success and @code{-1} on failure, and sets the
following errno:

@itemize @bullet
@item
@code{ENOTTY}: The passed file does not support the passed ioctl.

@item
@code{EBADF}: The passed file does not exist for the process.

@item
@code{EFAULT}: The passed argument is in non-accessible memory
@end itemize

@node sched_yield
@section sched_yield

@example c
int sched_yield(void);
@end example

This syscall relinquishes execution of the caller thread.
Its up for the kernel how far in the queue of execution this thread will go.

This syscall returns @code{0} always, as it never fails, this is done for
compatibility with POSIX instead of having a @code{void} return type.

@node pipe
@section pipe

@example c
int pipe(int pipefd[2], int flags);
@end example

This syscalls creates a pipe with the passed flags and returns the registered
file descriptors in @code{pipefd}. Index @code{0} is the reader end, @code{1}
is the writing one.

The only available flag for use is @code{O_NONBLOCK}.

The syscall returns @code{0} on success and @code{-1} on failure, with the
following errno:

@itemize @bullet
@item
@code{EFAULT}: @code{pipefd} points to bogus memory.
@item
@code{EMFILE}: No available file descriptor slots.
@end itemize

@node rename
@section rename

@example c
#define RENAME_NOREPLACE 1
int rename(int sourcedirfd, const char *sourcepath, size_t sourcelen,
       int targetirfd, const char *targetpath, size_t targetlen, int flags);
@end example

This syscalls renames a file in an atomic operation, it is only available in
between files in the same mountpoint. If @code{targetpath} exists, it will be
replaced, @code{RENAME_NOREPLACE} may be passed in @code{flags} for making the
call fail in said case instead of replacing silently.

The syscall return the new fd on success and @code{-1} on failure. The errno
codes set on failure are:

@itemize @bullet
@item
@code{EFAULT}: One of the passed values is outside addressable memory.

@item
@code{ENAMETOOLONG}: The passed path is too long.

@item
@code{EIO}: The operation could not be done out of an internal error.
@end itemize

@node listprocs
@section listprocs

@example c
struct procinfo @{
    char id[20];
    uint16_t id_len;
    uint16_t ppid;
    uint16_t pid;
    uint32_t uid;
    uint32_t flags;
@} __attribute__((packed));

size_t listprocs(struct procinfo *addr, size_t len);
@end example

This syscall writes a list of all processes available on the system to
@code{addr}, which contains @code{len} items.

The number of processes in the system is returned in success, and @code{-1} in
failure, with the following errno:

@itemize @bullet
@item
@code{EFAULT}: The array pointed by @code{addr} is outside accessible memory.
@end itemize

@node gettid
@section gettid

@example c
int gettid(void);
@end example

This syscall returns the current thread id. It never fails.

@node fcntl
@section fcntl

@example c
#define F_DUPFD         1
#define F_DUPFD_CLOEXEC 2
#define F_GETFD         3
#define F_SETFD         4
#define F_GETFL         5
#define F_SETFL         6
#define F_GETPIPE_SZ    7
#define F_SETPIPE_SZ    8
#define F_GETLK         9
#define F_SETLK         10
#define F_SETLKW        11

#define FD_CLOEXEC      0b01
#define FD_CLOFORK      0b10

#define F_RDLCK 1
#define F_UNLCK 2
#define F_WRLCK 3

struct flock @{
   uint16_t l_type;
   uint16_t l_whence;
   uint64_t l_start;
   uint64_t l_len;
   uint32_t l_pid;
@}

int fcntl(int fd, int cmd, void *arg);
@end example

This syscall is a multiplexed syscall that performs the operations described
below on the open file descriptor @code{fd}. The operation is determined by
@code{cmd} and may take an optional argument @code{arg}.

The syscall's return value will depend on the requested @code{cmd}, and is
detailed along the operations below.

The valid operations are:

@itemize @bullet
@item
@code{F_DUPFD}: Clones @code{fd} into a the first available file descriptor
starting by @code{arg}. Returns the resulting FD.

@item
@code{F_DUPFD_CLOEXEC}: The same as @code{F_DUPFD} but sets the close on exec
flag for the cloned FD if successful, in order to save a subsequent call.

@item
@code{F_GETFD}: The flags used for @code{fd} will be returned. These can be
@code{FD_CLOEXEC}, which if set, will signal that @code{fd} will be closed
should an @code{exec} call or similar happen, and @code{FD_CLOFORK}, which
signals that @code{fd} will not be cloned when calling @code{clone} or similar.

@item
@code{F_SETFD}: The flags for @code{fd} will be set with @code{arg} using
the same values returned by @code{F_GETFD}. The syscall will return @code{0}
on success.

@item
@code{F_GETFL}: Returns as the function result the file access mode
and status flags.

@item
@code{F_SETFL}: What @code{F_SETFD} is to @code{F_GETFD} for
@code{F_GETFL}.

@item
@code{F_GETPIPE_SZ}: If @code{fd} points to a FIFO or pipe, return
its size.

@item
@code{F_SETPIPE_SZ}: If @code{fd} points to a FIFO or pipe, the size will
be set to the value of @code{arg}. If the operation would cause data loss, it
will fail.

@item
@code{F_GETLK}: If @code{fd} points to a filesystem inode, the data passed
in @code{arg} will be taken as a pointer to a @code{flock} struct, and the
possibility to add the advisory lock described there will be checked.

POSIX advisory locks are advisory file description-bound marks that may be
used as a filesystem semaphore. They require processes to check them, and are
not automatic nor mandatory, thus, advisory.

If the lock could be placed, the passed struct's @code{l_type} will become
@code{F_UNLCK}, else, the call will fail and the fields used to write the
information regarding one of the conflicting locks. As all IPC, this data may
not be true once processed, it is merely informative.

POSIX advisory locks can be used for implementing PID lock files, as to
make sure only one instance of the same daemon is running.

@item
@code{F_SETLK}: The same as @code{F_GETLK}, but actually sets the passed lock.
If it cannot be set, it will return failure with @code{EAGAIN}. If an
overlapping lock already exists acquired by the same process, this call will
instead just update permissions and return success.

@item
@code{F_SETLKW}: The same as @code{F_SETLK}, but instead of being non-blocking,
this call will block until the passed lock can be set.
@end itemize

On failure, the syscall returns @code{-1}. The returned @code{errno} are:

@itemize @bullet
@item
@code{EINVAL}: The passed @code{cmd} is not implemented by the kernel.

@item
@code{EBADF}: The passed @code{fd} is not open.
@end itemize

@node exit_thread
@section exit_thread

@example c
void exit_thread(void);
@end example

This syscall terminates the calling thread "immediately".
Any open file descriptors belonging to the process to be closed, and any
threads of execution are terminated.

This syscall does not return any value, but it sets errno on failure:

@itemize @bullet
@item
@code{EACCES}: MAC disallowed this.
@end itemize

@node getentropy
@section getentropy

@example c
int getentropy(void *buffer, size_t length);
@end example

This syscall fills the buffer pointed to @code{buffer} with up to @code{length}
random bytes. These bytes can be used for cryptographic purposes.

The operation is the same as reading from @code{/dev/random}. It is provided
instead of just reading from the device as to avoid denial of service attacks
based on exhausting the file descriptor limit of the system, along with other
vulnerabilities and inconveniences related to the classic file interface.

The syscall returns @code{0} on success or @code{-1} on failure, and sets the
following errno:

@itemize @bullet
@item
@code{EFAULT}: @code{buffer} points to invalid memory.
@item
@code{EACCES}: MAC disallowed this.
@end itemize

@node mac_capabilities
@section mac_capabilities

@example c
#define MAC_CAP_SCHED     0b000000000000001
#define MAC_CAP_SPAWN     0b000000000000010
#define MAC_CAP_ENTROPY   0b000000000000100
#define MAC_CAP_SYS_MEM   0b000000000001000
#define MAC_CAP_USE_NET   0b000000000010000
#define MAC_CAP_SYS_NET   0b000000000100000
#define MAC_CAP_SYS_MNT   0b000000001000000
#define MAC_CAP_SYS_PWR   0b000000010000000
#define MAC_CAP_PTRACE    0b000000100000000
#define MAC_CAP_SETUID    0b000001000000000
#define MAC_CAP_SYS_MAC   0b000010000000000
#define MAC_CAP_SIGNALALL 0b000100000000000
#define MAC_CAP_SETGID    0b001000000000000
#define MAC_CAP_IPC       0b010000000000000
#define MAC_CAP_SYS_LOG   0b100000000000000

unsigned long get_mac_capabilities(void);
int set_mac_capabilities(unsigned long request);
@end example

These syscalls allow to fetch and set MAC capabilities on the way described in
@ref{Mandatory access control (MAC)}.

Both syscalls cannot fail, @code{get_mac_capabilities} always returns the
capabilities of the callee process and @code{set_mac_capabilities} always
returns @code{0}, settings will just be ignored if permission to change them
is not granted.

@node add_mac_permissions
@section add_mac_permissions

@example c
#define MAC_PERM_CONTENTS 0b000001
#define MAC_PERM_READ     0b000010
#define MAC_PERM_WRITE    0b000100
#define MAC_PERM_EXEC     0b001000
#define MAC_PERM_APPEND   0b010000
#define MAC_PERM_FLOCK    0b100000

int add_mac_permissions(const char *path, int flags);
@end example

This syscall adds permissions to access an inode or device as described in
@ref{Mandatory access control (MAC)}.

The syscall returns @code{0} on success or @code{-1} on failure, with the
following errno:

@itemize @bullet
@item
@code{EPERM}: MAC did not allow this.
@item
@code{EFAULT}: The passed pointer does not point to valid memory.
@item
@code{EAGAIN}: The system has reached a limit on registered rules.
@item
@code{EINVAL}: The passed rule is already covered or conflicts with an existent
one.
@end itemize

@node set_mac_enforcement
@section set_mac_enforcement

@example c
#define MAC_DENY            0b001
#define MAC_DENY_AND_SCREAM 0b010
#define MAC_KILL            0b100

int set_mac_enforcement(unsigned long request);
@end example

This syscall sets the action to take for enforcement on MAC issues as explained
in @ref{Mandatory access control (MAC)}.

The syscall returns @code{0} on success or @code{-1} on failure, with the
following errno:

@itemize @bullet
@item
@code{EACCES}: MAC was locked.
@end itemize

@node mount/umount
@section mount/umount

@example c
#define MNT_FAT   1
#define MNT_EXT   2
#define MNT_DEV   3

#define MS_RDONLY   0b0001
#define MS_REMOUNT  0b0010
#define MS_RELATIME 0b0100
#define MS_NOATIME  0b1000

#define MNT_FORCE 1

int mount(const char *source, int source_len, const char *target,
          int target_len, int fs_type, unsigned long flags);
int umount(const char *target, int target_len, int flags);
@end example

These syscalls mount and unmount filesystems. For @code{mount}, @code{source}
is the source device while @code{target} is where to mount in the
global virtual filesystem. For @code{umount}, @code{target} is the path to
unmount.

For @code{mount}, @code{fs_type} can be one of the following values to choose
the filesystem type to mount, it must be specified, detection is not done.

@itemize @bullet
@item
@code{MNT_FAT}: FAT family filesystem.
@item
@code{MNT_EXT}: EXT family filesystem.
@item
@code{MNT_DEV}: DevFS filesystem, cannot be used.
@end itemize

For @code{mount}, @code{flags} allows:

@itemize @bullet
@item
@code{MNT_RDONLY}: Mount as read-only.
@item
@code{MNT_REMOUNT}: Remount an existing filesystem.
@item
@code{MNT_RELATIME}: Use relative time for the mount, to know what it does,
@ref{Generic filesystem options}. Conflicts with @code{MNT_NOATIME}.\
@item
@code{MNT_NOATIME}: Do not track access times. To know what it does,
@ref{Generic filesystem options}.
@end itemize

For @code{umount}, @code{flags} allows the following options:

@itemize @bullet
@item
@code{MNT_FORCE}: Unmount the filesystem even if busy, can cause data loss.
@end itemize

These syscalls returns @code{0} on success or @code{-1} on failure, with the
following errno:

@itemize @bullet
@item
@code{EFAULT}: Incorrect addresses for the string arguments.
@item
@code{EACCES}: MAC forbid this operation.
@item
@code{EINVAL}: Wrong arguments.
@item
@code{EBUSY}: For @code{umount}, the mount is busy, and @code{MNT_FORCE} was
not passed.
@end itemize

@node readlink
@section readlink

@example c
ssize_t readlink(char *path, int path_len, char *buffer, size_t buffer_len);
@end example

The syscall reads the redirected path of a symlink.

The syscalls return the read length on success or @code{-1} on failure, with
the following errno:

@itemize @bullet
@item
@code{EFAULT}: Incorrect addresses for the string arguments.
@item
@code{EACCES}: MAC forbid this operation.
@item
@code{EINVAL}: The passed file is not a symbolic link.
@end itemize

@node getdents
@section getdents

@example c
#define DT_UNKNOWN 0
#define DT_FIFO    1
#define DT_CHR     2
#define DT_DIR     4
#define DT_BLK     6
#define DT_REG     8
#define DT_LNK    10
#define DT_SOCK   12
#define DT_WHT    14

struct dirent @{
   uint64_t d_ino;
   uint64_t d_off;
   uint16_t d_reclen;
   uint8_t  d_type;      // One of the DT_ values.
   char     d_name[256]; // Null-terminated.
@};

ssize_t getdents(int fd, struct dirent *buffer, size_t size);
@end example

This syscall reads the contents of the passed directory, and advances the
file position for the directory by the amount of read directory entries.
Partial reads are supported.

The syscalls return the read length in bytes on success, or @code{0} if no
contents or @code{-1} on failure, with the following errno:

@itemize @bullet
@item
@code{EFAULT}: Incorrect addresses for the arguments.
@item
@code{EBADFD}: @code{fd} does not contain a valid file.
@item
@code{ENOENT}: @code{fd} is not a directory.
@item
@code{EINVAL}: @code{size} is not big enough to fit all the directory entries.
@end itemize

@node sync
@section sync

@example c
int sync(void);
@end example

The syscall flushes the associated caches of all FSes and the devices that
contain said FSs, ensuring that all operations are finished, this can be used
in order to ensure data coherency on power loss or program failure.

The syscall returns @code{0} or @code{-1} on failure, with a corresponding
errno:

@itemize @bullet
@item
@code{EIO}: Device error while flushing.
@end itemize

@node mknod
@section mknod

@example c
int mknod(int dir_fd, const char *path, int path_len, int mode, int dev);
@end example

This syscall creates files in the passed path and dir. The type is chosen by
@code{code}, which uses the same format as @code{stat}'s mode field.

The syscall returns @code{0} or @code{-1} on failure, with the following errno:

@itemize @bullet
@code{EACCES}: Bad memory addresses.
@item
@code{EINVAL}: The passed path length is way too big, or the mode is invalid.
@item
@code{EIO}: Internal error.
@item
@code{EEXIST}: The object already exists.
@end itemize

@node truncate
@section truncate

@example c
int truncate(int fd, uint64_t new_size);
@end example

The syscall truncates the size of @code{fd} on disk to exactly @code{new_size}
bytes.

If the file was larger, the cropped contents are lost, if it was smaller, the
new data is zero'd out. No other file data is changed.

The syscall returns @code{0} or @code{-1} on failure, with the following errno:

@itemize @bullet
@item
@code{EBADF}: The file pointed by @code{fd} is not valid for truncation.
@item
@code{EINVAL}: @code{new_size} could not be set.
@end itemize

@node bind
@section bind

@example c
struct sockaddr @{
   uint32_t sun_family; // AF values of socket().
   char data[];
@};

int bind(int sockfd, const struct sockaddr *addr, unsigned int addrlen);
@end example

This syscall assigns a global address to the passed socket, the meaning and
nature of the address depends on the passed socket.

The actual structure passed for the @code{addr} argument will depend on
the address family, @code{sockaddr} is a catch-all placeholder value.

The syscall returns @code{0} on success or @code{-1} on failure, with the
following errno:

@itemize @bullet
@item
@code{EINVAL}: Invalid address, may be already in use.
@item
@code{EFAULT}: Bad memory address.
@item
@code{EBADFD}: The passed FD is not a socket.
@end itemize

@node mkdir
@section mkdir

@example c
int mkdir(int dir_fd, const char *path, int path_len, int mode);
@end example

This syscall creates directories in the passed path.

The syscall returns @code{0} or @code{-1} on failure, with the following errno:

@itemize @bullet
@code{EACCES}: Bad memory addresses.
@item
@code{EINVAL}: The passed path length is way too big.
@item
@code{EIO}: Internal error.
@end itemize

@node symlink
@section symlink

@example c
int symlink(int dir_fd, const char *path, int path_len,
            const char *target, int target_len, int mode);
@end example

This syscall creates symlinks for the passed path and mode.

The syscall returns @code{0} or @code{-1} on failure, with the following errno:

@itemize @bullet
@code{EACCES}: Bad memory addresses.
@item
@code{EINVAL}: The passed path and target lengths are way too big, or the
passed mode is invalid.
@item
@code{EIO}: Internal error.
@end itemize

@node connect
@section connect

@example c
int connect(int sockfd, const struct sockaddr *addr, unsigned int addrlen);
@end example

This syscall connects the passed socket to the passed global address.

If the passed socket is datagram-based, then @code{addr} is the address to
which datagrams are sent by default, and the only address from which datagrams
are received. If the socket is stream-based, the syscall attempts to make a
connection to the socket that is bound to the address specified by @code{addr}.

The syscall returns @code{0} on success or @code{-1} on failure, with the
following errno:

@itemize @bullet
@item
@code{EINVAL}: Invalid address, may not be bound.
@item
@code{EFAULT}: Bad memory address.
@item
@code{EBADFD}: The passed FD is not a socket.
@end itemize

@node openpty
@section openpty

@example c
int openty(int ptys[2]);
@end example

This syscalls creates a pair of pseudoterminals and returns the registered
file descriptors in @code{ptys}. Index @code{0} is the primary end
(also known as master), @code{1} is the secondary end (also known as slave).

The syscall returns @code{0} on success and @code{-1} on failure, with the
following errno:

@itemize @bullet
@item
@code{EFAULT}: @code{ptys} points to bogus memory.
@item
@code{EMFILE}: No available file descriptor slots.
@end itemize

@node fsync
@section fsync

@example c
int fsync(int fd, int flags);
@end example

The syscall does the same as @code{sync}, just only applied to @code{fd}. If
the passed file is a device, the device will flush its internal caches.

If the file was just created, one might considering synchronizing the parent
directory as well, as, depending on the FS and FS driver, parent directory
entries are stored separately to the file, EXT-series filesystems come to mind.

If @code{flags} is not zero, only the data of the passed descriptor will be
guaranteed to be flushed, and not modified metadata, this can be used in
order to minimize disk activity even further.

The syscall returns @code{0} or @code{-1} on failure, with the errno:

@itemize @bullet
@item
@code{EBADF}: The passed file is not open.
@item
@code{EINVAL}: The passed points to a non-synchronizable entity.
@item
@code{EIO}: FS or device error while flushing.
@end itemize

@node link
@section link

@example c
int link(int dir_fd, const char *path, int path_len,
         const char *target, int target_len);
@end example

This syscall creates hard links, the paths are not dereferenced in the case
of being symlinks.

The syscall returns @code{0} or @code{-1} on failure, with the following errno:

@itemize @bullet
@item
@code{EACCES}: Bad memory addresses.
@item
@code{EINVAL}: The passed path and target lengths are way too big.
@item
@code{EIO}: Internal error.
@end itemize

@node ptrace
@section ptrace

@example c
#define PTRACE_SYSCALL_PIPE 1

long ptrace(long request, pid_t pid, void *addr, void *data);
@end example

This syscall can be used for tracing, debugging, execution control, and info
reporting of data owned by a child process. The operations is indicated by
@code{request}, while the PID to act upon is @code{pid}, @code{addr} the
address in the child process to modify, and @code{data} what to modify with.

@code{request} can be one of:

@itemize @bullet
@item
@code{PTRACE_SYSCALL_PIPE (1)}: @code{data} will be taken as an FD in the
child process, which the kernel will use to report the state on every syscall
the child process does. The descriptor must be a pipe, no other files are
supported. Errors writing are silently ignored.
@end itemize

The syscall returns @code{0} or @code{-1} on failure, with the following errno:

@itemize @bullet
@item
@code{EACCES}: MAC did not allow this.
@item
@code{EPERM}: @code{pid} is not a child or does not exist.
@item
@code{EINVAL}: @code{request} is not valid.
@end itemize

@node listen
@section listen

@example c
int listen(int sockfd, int backlog);
@end example

This syscall marks the passed socket as a passive socket, that is, as a socket
that will be used to accept incoming connection requests using @code{accept}.

The passed socket must be stream based, as these are the only sockets with a
true sense of connection.

@code{backlog} is a recommendation as to the maximum length to which the
queue of pending connections for @code{sockfd} may grow. If a connection
request arrives when the queue is full, depending on the protocols involved,
the client may receive an error or the connection may be ignored so that a
later reattempt at connection succeeds.

The syscall returns @code{0} on success or @code{-1} on failure, with the
following errno:

@itemize @bullet
@item
@code{EINVAL}: Invalid value for backlog.
@item
@code{EBADFD}: The passed FD is not a socket.
@item
@code{ENOTSUPP}: The passed FD is a socket, but it is not a stream socket.
@end itemize

@node accept
@section accept

@example c
int accept(int sockfd, const struct sockaddr *addr, int *addrlen, int flags);
@end example

This syscall takes the first connection request of @code{sockfd} and creates
a new connected socket with the flags in @code{flags} (@code{SOCK_NONBLOCK} and
@code{SOCK_CLOEXEC}). @code{addr} is used for writing the address of the
connection request. @code{addrlen} must be the length of the available buffer,
and it will be written to be the actual length copied.

The syscall returns the added FD on success or @code{-1} on failure, with the
following errno:

@itemize @bullet
@item
@code{EINVAL}: Invalid value for backlog.
@item
@code{EBADFD}: The passed FD is not a socket and listening.
@item
@code{ENOTSUPP}: The passed FD is a socket, but it is not a stream socket.
@end itemize

@node rlimit
@section rlimit

@example c
#define RLIMIT_CORE   1 // Size of core files, 0 for disabling.
#define RLIMIT_CPU    2 // CPU time limit in seconds.
#define RLIMIT_FSIZE  4 // Maximum file size in bytes.
#define RLIMIT_NOFILE 5 // Maximum number of open file descriptors.
#define RLIMIT_STACK  6 // Maximum stack size in bytes.
#define RLIMIT_AS     7 // Maximum memory size in bytes.

struct ulimit @{
    uint64_t soft;
    uint64_t hard;
@};

int rlimit(int resource, struct ulimit *new, struct ulimit *old);
@end example

This syscall fetches and sets current limits for a specified resource, hard
limits can only be lowered, are inherited from parent to children, and start
maxed out. Soft limits can be moved around.

The available limits are:

@itemize @bullet
@item
@code{RLIMIT_CORE}: Core files exceeding this size will be truncated, with 0,
core files are not generated.
@item
@code{RLIMIT_CPU}: Once the limit is passed, the process is killed.
@item
@code{RLIMIT_FSIZE}: System call growing the file fails with @code{EFBIG}.
@item
@code{RLIMIT_NOFILE}: Adding a new file descriptor fails with @code{EMFILE}.
@item
@code{RLIMIT_STACK}: The value is used for the size of created stacks, thus
there is no failure condition.
@item
@code{RLIMIT_AS}: @code{mmap} or other virtual memory allocation syscalls will
fail with @code{ENOMEM}.
@end itemize

This syscall returns @code{0} on success or @code{-1} on failure, with the
following errno:

@itemize @bullet
@item
@code{EFAULT}: One of the passed buffers was not 0 and not accessible.
@item
@code{EINVAL}: Invalid value for resource.
@item
@code{EPERM}: MAC did not allow the operation.
@end itemize

@node sched_rr_interval
@section sched_rr_interval

@example c
int sched_rr_interval(int pid, struct timespec *new, struct timespec *old);
@end example

This syscall fetches and/or sets current quantum periods for the passed process
for use under @code{SCHED_RR} scheduling policies.

If @code{pid} is 0, the PID of the caller is used. Both the @code{new} and
@code{old} values are nullable.

This syscall returns @code{0} on success or @code{-1} on failure, with the
following errno:

@itemize @bullet
@item
@code{EFAULT}: One of the passed buffers was not 0 and not accessible.
@item
@code{ESRCH}: Invalid PID passed.
@item
@code{EPERM}: MAC did not allow the operation.
@end itemize

@node access
@section access

@example c
#define F_OK 0b0001
#define R_OK 0b0010
#define W_OK 0b0100
#define X_OK 0b1000

#define AT_EACCESS 512

int access(int dir_fd, char *path, int len, mode_t mode, int flags);
@end example

This syscall whether the callee process can access the passed file against
POSIX file permissions and Ironclad's MAC. What to check for is specified in
@code{mode} as an ORd list, as such:

@itemize @bullet
@item
@code{F_OK}: When passed, only file existence will be checked.
@item
@code{R_OK}: When passed, read permissions will be checked.
@item
@code{W_OK}: When passed, write permissions will be checked.
@item
@code{X_OK}: When passed, execute permissions will be checked.
@end itemize

Permissions are checked with the real user and group IDs, instead of the
effective ones, that behaviour can be changed by passing @code{AT_EACCESS} in
@code{flags}, which can also be used for other common AT flags.
@code{AT_EMPTY_PATH} is not accepted because that does not make any sense with
this syscall.

The syscall returns @code{0} on success when the passed mode is checked valid,
or @code{-1} on check failure, with the following errno:

@itemize @bullet
@item
@code{EBADF}: @code{dirfd} is not valid.
@item
@code{ENOENT}: The requested file does not exist.
@item
@code{EACCES}: The access is not allowed.
@end itemize

@node ppoll
@section ppoll

@example c
#define POLLIN   0b00000001
#define POLLOUT  0b00000010
#define POLLPRI  0b00000100
#define POLLHUP  0b00001000
#define POLLERR  0b00010000
#define POLLNVAL 0b01000000

struct pollfd @{
   uint32_t fd;
   uint16_t events;
   uint16_t revents;
@};

int poll(struct pollfd *fds, nfds_t nfds, struct timespec *timeout,
   const sigset_t *sigmask);
@end example

This syscall allows to wait for a series of events to happen to the passed
FDs, in a manner similar to POSIX's @code{select}.

@code{fds} is an array of @code{nfds} length of @code{pollfd} structures. Each
structure represents one FD, for which @code{events} is a list of events
to wait for and @code{revents} is a bitmap written by the kernel to indicate
which events of the waited ones did happen. If the FD of an structure is
negative, that is, it has the first bit set, it is ignored, and @code{revents}
is set to @code{0}.

If passed no FDs to ppoll, that is, with @code{nfds == 0}, @code{ppoll} will
block for @code{timeout} time. This is used by some software as a means to
implement @code{sleep}/@code{pause} functionality, for those cases,
@ref{clock_nanosleep}.

If @code{sigmask} is not @code{NULL}, it will atomically set the passed
sigmask for waiting.

Both @code{events} and @code{revents} are bitmaps of the values:

@table @code
@item POLLIN
The passed FD has data pending for reading.

@item POLLOUT
The passed FD will not block when written to.

@item POLLPRI
The passed FD has prioritary data for processing, this data depends on what is
polled, some examples are a change of termios information on a PTY, or
Out-Of-Band (OOB) data for a TCP socket.

@item POLLERR
Only for @code{revents}, it is set when encountering an error waiting. This bit
is also set for FDs referring to the write end of a pipe when the read end has
been closed.

@item POLLHUP
Only for @code{revents}, it is set in the case of the passed FD having lost
connection, or the FD being the reader end of a broken pipe.

@item POLLNVAL
Only for @code{revents}, equivalent of @code{EBADFD}, that is, the passed FD
is not valid.
@end table

The call will block until either a file descriptor gets an event, the call is
interrupted by a signal handler, or the timeout expires.

The syscall returns the number of FDs to have an event happen on success or
@code{-1} on failure, with the following errno:

@table @code
@item EFAULT
The passed pointers are not in addressable memory.

@item EINVAL
The passed values are not valid.
@end table

@node getuid/geteuid
@section getuid/geteuid

@example c
uid_t getuid(void);
uid_t geteuid(void);
@end example

These syscalls fetch the UID and the effective UID of the calling process. They
never fail.

@node setuids
@section setuids

@example
int setuids(uid_t uid, uid_t euid);
@end example

This syscall sets the UID and effective UID of the calling process. If the
calling process has the @code{MAC_CAP_SETUID} capability, it will set both
the EUID and UID, else, it will only try to set EUID to values matching the
process's UID. If any of them is @code{-1}, it will not be modified.

The syscall returns @code{0} on success or @code{-1} on failure, with the
following errno:

@table @code
@item EPERM
MAC did not allow this.
@end table

@node fchmod
@section fchmod

@example c
int fchmod(int dir_fd, char *path, int len, mode_t mode, int flags);
@end example

This syscall sets the mode for the passed arguments in the same way
@ref{fstat} fetches information for the passed arguments.

The syscall returns @code{0} on success or @code{-1} on failure, with the
following errno:

@table @code
@item EINVAL
The passed FD or mode is not valid.

@item EACCES
MAC did not allow this.
@end table

@node umask
@section umask

@example c
mode_t umask(mode_t mask);
@end example

This syscall sets the umask of the calling process to the passed mask AND'd
with @code{777} in octal.

The umask is used by the kernel when creating files in the name of the calling
process. It marks permissions to be turned off from @code{mode} arguments
passed by the user. The default value is @code{22} in octal, and is inherited
from parent processes to children.

This syscall never fails, it always returns the old mask before modification.

@node reboot
@section reboot

@example c
#define RB_HALT     1
#define RB_POWEROFF 2
#define RB_RESTART  3
#define RB_ERROR_RET 0b1

int reboot(int cmd, int flags);
@end example

This syscall does the passed action to the system's power management, the
action is specified with @code{cmd}, it can be one of:

@table @code
@item RB_HALT
System activity is terminated and the system will make all needed preparations,
but power will not be cut off, instead, the user will have to do so, say, with
the power button. Data syncing is up to the user.

@item RB_POWEROFF
The same as @code{RB_HALT} but actually cuts power.

@item RB_RESTART
The same as @code{RB_HALT} but at the end, the system will reboot.
@end table

If the operation fails internally, for any reason, the kernel will panic, for
returning an error instead, one can use @code{RB_ERROR_RET} in @code{flags}.

This syscall does not return on success, it will only return in the case of
invalid value for @code{cmd}, before committing to an operation, or by using
@code{RB_ERROR_RET} as previously said. In error, @code{-1} will be returned,
and errno will be set to:

@table @code
@item EINVAL
The passed @code{cmd} is not valid.

@item EACCES
MAC did not allow this.

@item EIO
The operation failed internally.
@end table

@node fchown
@section fchown

@example c
int fchown(int dir_fd, char *path, int len, uint32_t user, uint32_t group,
   int flags);
@end example

This syscall sets the owner's UID and GID for the passed arguments in the same
way @ref{fstat} fetches information for the passed arguments.

The syscall returns @code{0} on success or @code{-1} on failure, with the
following errno:

@table @code
@item EINVAL
The passed FD or the user and group were not valid.

@item EACCES
MAC did not allow this.

@item EBADF
The passed file is valid but it was not a physical file in a filesystem.
@end table

@node getpgid/setpgid
@section getpgid/setpgid

@example c
pid_t getpgid(pid_t pid);
int setpgid(pid_t pid, pid_t pgid);
@end example

This syscalls get and set the process group ID of a process, which is a
separate ID inherited from parent to children processes used for grouping
processes for operations like waiting or signal handling. The group ID of
the first process started by Ironclad is @code{0}, and userland takes care of
it from there.

Both syscalls allow their arguments to be @code{0}. When @code{0} is passed,
it will be taken to be the PID of the calling process for either the
@code{pid} or @code{pgid} fields.

On success, @code{getpgid} returns the desired group ID, and @code{setpgid}
returns @code{0}. On failure, both syscalls return @code{-1} with the
following errno:

@table @code
@item ESRCH
The passed PID is not valid.
@end table

@node getsid/setsid
@section getsid/setsid

@example c
pid_t getsid(pid_t pid);
pid_t setsid(void);
@end example

This syscalls get and set the session ID of a process, which is a
separate ID inherited from parent to children processes. The session ID of
the first process started by Ironclad is @code{0}, and userland takes care of
it from there.

@code{getsid} allows its arguments to be @code{0}. When @code{0} is passed,
it will be taken to be the PID of the calling process.

On success, @code{getsid} returns the session ID, and @code{setsid}
returns the new session ID. On failure, both syscalls return @code{-1} with the
following errno:

@table @code
@item ESRCH
The passed PID is not valid.
@end table

@node getsockname
@section getsockname

@example c
int getsockname(int sockfd, struct sockaddr *restrict addr, socklen_t *restrict addrlen);
@end example

This syscall fetches the address of an already bound socket.

The syscall returns @code{0} on success or @code{-1} on failure, with the
following errno:

@table @code
@item EINVAL
The passed FD was a non bound socket.

@item EBADF
The passed file is valid but it was not a physical file in a filesystem.
@end table

@node getpeername
@section getpeername

@example c
int getpeername(int sockfd, struct sockaddr *restrict addr, socklen_t *restrict addrlen);
@end example

This syscall fetches the address of a socket's peer.

The syscall returns @code{0} on success or @code{-1} on failure, with the
following errno:

@table @code
@item EINVAL
The passed FD was a non bound socket.

@item EBADF
The passed file is valid but it was not a physical file in a filesystem.
@end table

@node shutdown
@section shutdown

@example c
#define SHUT_RD   0b01
#define SHUT_RDWR 0b10
#define SHUT_WR   0b11

int shutdown(int sockfd, int how);
@end example

This syscall stops transmission or reception for a socket from a peer.

@code{how} signals how to stop communication, it can be the following values:

@table @code
@item SHUT_RD
Further receiving will not be allowed.

@item SHUT_WR
Further transmitting will not be allowed.

@item SHUT_RDWR
Further receiving and transmitting will not be allowed.
@end table

The syscall returns @code{0} on success or @code{-1} on failure, with the
following errno:

@table @code
@item EINVAL
The passed FD was a non bound socket.

@item EBADF
The passed file is valid but it was not a physical file in a filesystem.
@end table

@node futex
@section futex

@example c
struct futex_item @{
    uint64_t addr;
    uint32_t expected;
    uint32_t flags;
@};

#define FUTEX_WAIT 1
#define FUTEX_WAKE 2

int futex(int operation, struct futex_item *futexes, size_t count,
    struct timespec *time);
@end example

This syscall helps implement fast userland mutexes (futexes!). It is typically
used as a blocking construct in the context of shared-memory synchronization.

When using futexes, the majority of the synchronization operations are
performed in user space by atomically testing for a 32-bit value. User-space is
to use @code{futex} only when it is likely that the program has to block for a
longer time until the condition becomes true. Other @code{futex} operations
can be used to wake any processes or threads waiting for an address.

When executing a futex operation that requests to block a thread, the kernel
will block only if the futex contents has the value that the call supplied under
@code{expected}. The loading of the futex's contents and comparison of that
value are atomic, and will be totally ordered with respect to concurrent
operations performed by other threads on the same futex contents. Thus, the
futex contents are used to connect the synchronization in user space with the
implementation of blocking by the kernel. Analogously to an atomic
compare-and-exchange operation that potentially changes shared memory, blocking
via a futex is an atomic compare-and-block operation. When blocked, the kernel
will calmly wait for waking by @code{FUTEX_WAKE}, waking is not automatic once
the values are acquired.

Note that no explicit initialization or destruction is necessary to use
futexes; the kernel maintains a futex only while operations such as
@code{FUTEX_WAIT} are being performed on particular futex contents.

When compared with other implementations like Linux's, Ironclad's allows for
waiting and waking several futexes at once.

The available futex operations are:

@table @code
@item FUTEX_WAIT
The passed values in futexes will be waited for.

@item FUTEX_WAKE
The passed values in futexes will be woken up.
@end table

When waiting, the syscall returns @code{0} on success or @code{-1} on failure,
with the following errno:

@table @code
@item EFAULT
The passed addresses would fault if accessed.

@item EINVAL
The passed operation is not valid.

@item EAGAIN
When waiting, a passed @code{addr} did not point to a @code{expected}.
@end table

When waking, the syscall returns the number of awoken futexes on success
instead.

@node clock
@section clock

@example c
#define CLOCK_REALTIME  0
#define CLOCK_MONOTONIC 1
#define CLOCK_GETRES    0
#define CLOCK_GETTIME   1
#define CLOCK_SETTIME   2

int clock(int operation, int clock_id, struct timespec *time);
@end example

This syscall fetches or sets epoch dates for each of the supported clocks.
Clock is passed in @code{clock_id}, with the following values.

@table @code
@item CLOCK_REALTIME
Wall-clock, may jump forward and back thanks to time setting.

@item CLOCK_MONOTONIC
Clock that only moves forward, and is unaffected by NTP or adjustments. It
starts from an unspecified, target-dependent point in time, usually boot.

Unlike Linux, it is still counted during suspend.
@end table

@code{operation} specifies what to do, as such:

@table @code
@item CLOCK_GETRES
Load the resolution of the passed clock on the contents of @code{time}.

@item CLOCK_GETTIME
Load the epoch date of the passed clock on the contents of @code{time}.

@item CLOCK_SETTIME
Set the epoch date of the passed clock to the contents of @code{time}, not
supported for @code{CLOCK_MONOTONIC}. Underlying hardware will always be
updated.
@end table

The syscall returns @code{0} on success or @code{-1} on failure, with the
following errno:

@table @code
@item EFAULT
@code{time} points to non accessible memory.

@item EINVAL
One of the passed values is not valid.
@end table

@node clock_nanosleep
@section clock_nanosleep

@example c
#define TIMER_ABSTIME 1

int clock_nanosleep(int clock_id, int flags, struct timespec *time,
   struct timespec *remaining);
@end example

This syscall sleeps the callee thread for the passed time with the requested
clock. If interrupted by a signal or similar, it returns the remaining time
that could not be waited.

Unlike what POSIX mandates, this syscall will always need @code{remaining} to
be a valid structure. @code{clock_id} takes the same value as @ref{clock}.

@code{flags} can be one of the following:

@table @code
@item TIMER_ABSTIME
Instead of an increment on top of the current time, @code{time} is taken as an
absolute time (ideally in the future!).
@end table

The syscall returns @code{0} on success or @code{-1} on failure, with the
following errno:

@table @code
@item EFAULT
@code{time} or @code{remaining} point to non accessible memory.

@item EINVAL
One of the passed values is not valid.

@item EPERM
MAC did not allow this.
@end table

@node getrusage
@section getrusage

@example c
#define RUSAGE_SELF 1
#define RUSAGE_CHILDREN 2

struct rusage @{
    struct timeval ru_utime; // user CPU time used.
    struct timeval ru_stime; // system CPU time used.
@};

int getusage(int who, struct rusage *usage);
@end example

This syscall gets the use of several resources by a process.

Unlike what POSIX mandates, this syscall will always need @code{remaining} to
be a valid structure. @code{clock_id} takes the same value as @ref{clock}.

Due to implementation details, for now, system time does include waiting time,
but given this syscall's information is merely advisory, it may be changed
later.

@code{who} establishes who to request the information for, it can be one of:

@table @code
@item RUSAGE_SELF
Get information for the callee process.

@item RUSAGE_CHILDREN
Get information for all of the children processes.
@end table

The syscall returns @code{0} on success or @code{-1} on failure, with the
following errno:

@table @code
@item EFAULT
@code{usage} point to non accessible memory.

@item EINVAL
@code{who} was not valid.
@end table

@node recvfrom/sendto
@section recvfrom/sendto

@example c
ssize_t recvfrom(int socket_fd, void *restrict buffer, size_t length,
   int flags, struct sockaddr *address, socklen_t *address_len);
ssize_t sendto(int socket_fd, void *restrict buffer, size_t length,
   int flags, struct sockaddr *address, socklen_t address_len);
@end example

These syscalls compliment @code{read} and @code{write} for socket-based IO.
They allow specifying or fetching the address of a read or write operation when
doing them, which can be vital for reading connection-less socket protocols.

Unlike doing @code{connect} on a connection-less socket, the addresses passed
here will not affect future transactions.

When used for connection-based protocols, or when passed as @code{NULL},
@code{address} and @code{address_len} will be ignored.

@code{flags} is right now a placeholder for future options.

These syscalls return and fail in the same ways @ref{read/write} would, with
the addition of only accepting sockets as their passed @code{socket_fd}.

@node config_netinter
@section config_netinter

@example c
#define NETINTER_SET_BLOCK      1
#define NETINTER_SET_STATIC_IP4 2
#define NETINTER_SET_STATIC_IP6 3

struct addr4_netinter @{
    uint32_t ip;
    uint32_t sub;
@};

struct addr6_netinter @{
    uint128_t ip;
    uint128_t sub;
@};

int config_netinter (int fd, int op, void *arg);
@end example

This syscall configures networking interfaces by using the device that
implements the desired interface.

@code{op} dictates what the arguments and action to do are, it can be one of:

@table @code
@item NETINTER_SET_BLOCK
@code{arg} will be a pointer to a boolean value, if it evaluates to true, the
passed interface will be blocked, if it evaluates to false, it will be
unblocked.

@item NETINTER_SET_STATIC_IP4
@code{arg} will be a pointer to a @code{addr4_netinter} structure, which
specifies an address and subnet to set as static addresses.

@item NETINTER_SET_STATIC_IP6
@code{arg} will be a pointer to a @code{addr6_netinter} structure, which
specifies an address and subnet to set as static addresses.
@end table

The syscall returns @code{0} on success or @code{-1} on failure, with the
following errno:

@table @code
@item EFAULT
@code{arg} point to non accessible memory.

@item EACCES
MAC did not allow this.

@item EINVAL
An argument is not valid.
@end table

@node utimes
@section utimes

@example c
int utimes(int dir, const char *path, struct timespec *times, int flags);
@end example

This syscall changes the access and modification time of the passed file to the
2 first values contained in the @code{times} array. All the standard options
for @code{dir} are accepted and @code{flags} takes @code{AT_EMPTY_PATH} and
@code{AT_SYMLINK_NOFOLLOW}.

@table @code
@item EFAULT
@code{path} or @code{times} point to non accessible memory.

@item EACCES
MAC did not allow this.

@item EINVAL
An argument is not valid.
@end table

@node get/set_scheduler
@section get/set_scheduler

@example c
#define SCHED_OTHER 0
#define SCHED_FIFO  1
#define SCHED_RR    2
#define SCHED_IDLE  5

struct sched_param @{
	int32_t sched_priority;
@};

int sched_getscheduler(pid_t pid, struct sched_param *param);
int sched_setscheduler(pid_t pid, int policy, struct sched_param *param);
@end example

This syscalls get and set scheduler details for the passed process. @code{pid}
can be either a PID or @code{0} for the caller. @code{param} stands for the
scheduler-specific parameters of the passed PID. For both calls @code{param}
can be passed @code{NULL} for the OS to not modify or read it.

@code{param}'s priority is only used for the real time policies, and is
delimited by the values returned at @pxref{get_min/max_priority}.

@code{sched_getscheduler} returns the scheduler policy or @code{-1} on failure,
@code{sched_setscheduler} returns @code{0} on success or @code{-1} on failure.
Both operations return the following errno on failure:

@table @code
@item EINVAL
@code{pid} is not valid.

@item EFAULT
A non-@code{NULL} pointer points to not valid memory.
@end table

@node get_min/max_priority
@section get_min/max_priority

@example c
int get_min_prio(void);
int get_max_prio(void);
@end example

This syscalls return the minimum and maximum priority that the params for
@code{sched_setscheduler} take, they never fail.

@node sigprogmask
@section sigprogmask

@example c
#define SIG_BLOCK   1
#define SIG_UNBLOCK 2
#define SIG_SETMASK 3

int sigprocmask(int how, sigset_t *set, sigset_t *oldset);
@end example

This syscall fetches and/or changes the signal mask of the calling
process. The signal mask is the set of signals whose delivery is currently
blocked.

If not @code{NULL}, @code{set} can be used for passing a new mask, if not
@code{NULL}, @code{oldset} can be used for getting the existing mask.

The behaviour of the syscall will depend on the value passed to
@code{how}, which can be one of:

@table @code
@item SIG_BLOCK
The blocked signals will be a union of the current ones and the passed ones.

@item SIG_UNBLOCK
The blocked signals will be the current ones minus the passed ones.

@item SIG_SETMASK
The blocked signals will be the passed ones.
@end table

It returns @code{0} on success and @code{-1} on failure, with the following
errno:

@table @code
@item EINVAL
@code{how} is not valid.

@item EFAULT
A non-@code{NULL} pointer points to not valid memory.
@end table

@node sigaction
@section sigaction

@example c
struct sigaction @{
    void (*sa_sigaction)(int, siginfo_t *, void *);
    void (*sa_restorer)(void);
    sigset_t sa_mask;
    int sa_flags;
@};

int sigaction(int sig, struct sigaction *act, struct sigaction *oldact);
@end example

This syscall fetches and/or changes the associated actions with the signal
@code{sig}.

If not @code{NULL}, @code{act} can be used for setting a new action, if not
@code{NULL}, @code{oldact} can be used for getting the existing action.

It returns @code{0} on success or @code{-1} on failure, with the following
errno:

@table @code
@item EINVAL
@code{sig} is not valid.

@item EFAULT
A non-@code{NULL} pointer points to not valid memory.

@item EPERM
The caller does not have the appropriate permissions over @code{pid} to actually
kill.
@end table

@node send_signal
@section send_signal

@example c
int send_signal(int pid, int signal);
@end example

This syscall sends the passed signal to the passed PID.

@code{pid} can be one of four values:

@itemize @bullet
@item @code{Lesser than -1}: @code{pid} is taken as a process group ID.
@item @code{-1}: Signals are sent to any process that we can send to but init
(PID 1) or the caller process.
@item @code{0}: Signals are sent to any process in the caller's process group,
including the caller process.
@item @code{Greater than 0}: @code{pid} is taken as the PID to send to.
@end itemize

Only processes sharing the same UID or EUID as the caller's EUID can be
signaled. The @code{MAC_CAP_SIGNALALL} capability overrides this check.

If @code{signal} is @code{0}, instead of a signal being sent, only the
permissions to send one are checked.

It returns @code{0} on success and @code{-1} on failure, with the following
errno:

@table @code
@item ESRCH
@code{pid} is not a valid target for sending.

@item EPERM
The caller does not have permissions to signal @code{pid}.

@item EINVAL
@code{signal} is not a valid signal.
@end table

@node getprio/setprio
@section getprio/setprio

@example c
#define PRIO_PROCESS 1
#define PRIO_PGRP 2
#define PRIO_USER 3
#define PRIO_THREAD 4

#define PRIO_MIN (-20)
#define PRIO_MAX 20

int getprio(int which, int who);
int setprio(int which, int who, int prio);
@end example

These syscalls get and set niceness values, @code{which} says which entity
to set the niceness to, while @code{who} the pid or id of the entity, 0 for
the current caller.

@code{who} can be one of:

@table @code
@item PRIO_PROCESS
Get or set the default niceness of a process. When set, this will make new
threads created by a process be created with this niceness value, and make all
exiting threads have that niceness, along with making child processes inherit
the passed niceness.

@item PRIO_PGRP / PRIO_USER
Unimplemented, for future features.

@item PRIO_THREAD
Get or set the niceness of the passed thread. Setting this value does not
affect the process niceness, or what will be reported when getting it, it will
just be an outliar until niceness is set again, either thread-wide or
process-wide.
@end table

@code{getprio} returns the niceness and @code{-1} on failure, while
@code{setprio} returns @code{0} on success and @code{-1} on failure. Both
in failure feature the following errno:

@table @code
@item EINVAL
A value is not valid.
@end table

@node getgid/getegid
@section getgid/getegid

@example c
gid_t getgid(void);
gid_t getegid(void);
@end example

These syscalls fetch the GID and the effective GID of the calling process. They
never fail.

@node setgids
@section setgids

@example c
int setgids(gid_t gid, gid_t egid);
@end example

This syscall sets the GID and effective GID of the calling process. If the
calling process has the @code{MAC_CAP_SETGID} capability, it will set both
the EGID and GID, else, it will only try to set EGID to values matching the
process's GID. If any of them is @code{-1}, it will not be modified.

The syscall returns @code{0} on success or @code{-1} on failure, with the
following errno:

@table @code
@item EPERM
MAC did not allow this.
@end table

@node getgroups/setgroups
@section getgroups/setgroups

@example c
int getgroups(size_t size, gid_t list[]);
int setgroups(size_t size, const gid_t *list);
@end example

This syscall gets and sets the supplementary user groups of the caller process.
The stored group IDs, along with the effective GID, will be used to check
permission for file access. among others permission checks.

@code{getgroups} does not return the effective GID of the caller process on
the list. POSIX leaves whether the effective GID is included on this list as
an implementation detail, so portable programs should be ready for that
scenario.

Init starts with an empty array of supplementary group IDs.

Passing @code{0} and @code{NULL} to @code{setgroups} will empty the
supplementary group list.

@code{getgroups} returns the number of supplementary groups or @code{-1} on
failure, @code{setgroups} returns @code{0} on success and @code{-1} on failure,
both with the following errno:

@table @code
@item EINVAL
@code{getgroups} size is less than the number of supplementary group IDs.
@end table

@node ttyname
@section ttyname

@example c
int ttyname(int fd, char *buffer, size_t size);
@end example

This syscall fetches the name of the filesystem entity backing a TTY and writes
it to @code{buffer} with a NULL terminator.

The syscall returns @code{0} on success or @code{-1} on failure, with the
following errno:

@table @code
@item EINVAL
@code{size} is less than needed and/or @code{fd} is not a TTY.

@item EBADF
@code{fd} is not opened to anything.

@item EFAULT
@code{buffer} points to invalid memory.
@end table

@node fadvise
@section fadvise

@example c
#define POSIX_FADV_NORMAL     1
#define POSIX_FADV_SEQUENTIAL 2
#define POSIX_FADV_NOREUSE    3
#define POSIX_FADV_DONTNEED   4
#define POSIX_FADV_WILLNEED   5
#define POSIX_FADV_RANDOM     6

int fadvise(int fd, off_t offset, off_t len, int advice);
@end example

This syscall is used for advising the kernel on how access will be done for
the passed file for the passed range, in order to prepare caches ahead of time
to optimize system resource use and performance. This can only be used with
filesystem inodes.

Advising for a file does not make any operation illegal or behave weirdly, they
are just used in order to cater to the passed information.

Advice is indicated on @code{advice}, and can take the following values:

@table @code
@item POSIX_FADV_NORMAL
Indicates that the application has no advice to give about its access pattern
for the specified data. If no advice is given for an open file, this is the
default assumption.

@item POSIX_FADV_SEQUENTIAL
Specifies that the application has no advice to give on its behavior with
respect to the specified data. It is the default characteristic if no advice is
given for an open file.

@item POSIX_FADV_NOREUSE
Specifies that the application expects to access the specified data once and
then not reuse it thereafter.

@item POSIX_FADV_DONTNEED
Specifies that the application expects that it will not access the specified
data in the near future.

@item POSIX_FADV_WILLNEED
Specifies that the application expects to access the specified data in the near
future.

@item POSIX_FADV_RANDOM
Specifies that the application expects to access the specified data in a random
order.
@end table

The syscall returns @code{0} on success or @code{-1} on failure, with the
following errno:

@table @code
@item EINVAL
@code{advice} is not valid.

@item EBADF
@code{fd} is not opened to anything.

@item ESPIPE
The passed file is not a VFS inode.
@end table

@node shmat
@section shmat

@example c
void *shmat(int shmid, const void *shmaddr, int shmflg);
@end example

This syscall attaches the shared memory segment identified by @code{shmid} to
the address space of the calling process.

If shmaddr is @code{NULL}, the system chooses a suitable (unused) address at
which to attach the segment. If it is not @code{NULL}, that address will be
used for attaching.

If @code{SHM_RDONLY} is specified in shmflg, the segment is attached for
reading and the process must have read permission for the segment. Otherwise
the segment is attached for read and write and the process must have read and
write permission for the segment. There is no notion of a write-only shared
memory segment.

The syscall returns @code{0} on success or @code{-1} on failure, with the
following errno:

@table @code
@item EACCES
The caller does not have enough permissions for attaching.

@item EIDRM
@code{shmid} points to a removed identifier.

@item EINVAL
Invalid @code{shmid} or invalid @code{shmaddr}.

@item ENOMEM
Not enough memory.
@end table

@node shmctl
@section shmctl

@example c
struct ipc_perms @{
   uint32_t __key;
   uint32_t uid;
   uint32_t gid;
   uint32_t cuid;
   uint32_t cgid;
   uint32_t mode;
   uint32_t __seq;
   uint64_t reserved[2];
@}

struct shmid_ds @{
   struct ipc_perms shm_perm;
   uint64_t shm_segsz;
   uint64_t shm_atime;
   uint64_t shm_dtime;
   uint64_t shm_ctime;
   uint32_t shm_cpid;
   uint32_t shm_lpid;
   uint64_t shm_nattch;
@}

#define IPC_RMID 0
#define IPC_SET  1
#define IPC_STAT 2

int shmctl(int shmid, int cmd, struct shmid_ds *buf);
@end example

This syscall performs the control operation specified by @code{cmd} on the
shared memory segment whose identifier is given in @code{shmid}.

@code{cmd} can be one of:

@table @code
@item IPC_RMID
The passed @code{shmid} is set to be deleted when the attached count of the
segment goes to @code{0}. Otherwise, it will linger forever. @code{buf} is
ignored.

@item IPC_SET
Information passed on the structure pointed to by @code{buf} is used to modify
the permission fields of the passed segment, namely @code{shm_perm.uid},
@code{shm_perm.gid}, and @code{shm_perm.mode}.

@item IPC_STAT
Get the associated information of the passed segment id and write it to the
structure pointed to by @code{buf}.
@end table

The syscall returns @code{0} on success or @code{-1} on failure, with the
following errno:

@table @code
@item EINVAL
@code{size} is less than needed and/or @code{fd} is not a TTY.

@item EBADF
@code{fd} is not opened to anything.

@item EFAULT
@code{buffer} points to invalid memory.
@end table

@node shmdl
@section shmdl

@example c
int shmdt(const void *shmaddr);
@end example

This syscall detaches the shared memory segment located at @code{shmaddr} from
the calling process.

The syscall returns @code{0} on success or @code{-1} on failure, with the
following errno:

@table @code
@item EINVAL
The passed @code{shmaddr} is not valid.
@end table

@node shmget
@section shmget

@example c
#define IPC_PRIVATE 0

int shmget(key_t key, size_t size, int shmflg);
@end example

This syscall fetches or creates a shared memory segment associated with
@code{key}.

If @code{key} is equal to @code{IPC_PRIVATE}, a segment will be created with
no associated key, and will need to be accessed by other processes only by
the returned @code{shmid}.

The syscall returns a valid ID on success or @code{-1} on failure, with the
following errno:

@table @code
@item EACCES
MAC did not allow this.

@item EEXISTS
An attempt to create a public segment with an already registered key happened.

@item ENOENT
The fetched segment is not present.
@end table

@node getsockopt/setsockopt
@section getsockopt/setsockopt

@example c
#define SOL_SOCKET 1

#define SO_ACCEPTCONN 1
#define SO_ERROR      5
#define SO_SNDBUF     13
#define SO_TYPE       16
#define SO_PEERCRED   18
#define SO_PASSCRED   20

int getsockopt(int fd, int level, int name, void *val, socklen_t *len);
int setsockopt(int fd, int level, int name, void *val, socklen_t len);
@end example

This syscall gets or sets the option passed on @code{name} for the socket level
passed on @code{level}, and writes or fetches data from @code{val} with the
length passed on @code{len}.

Right now, @code{SOL_SOCKET} is the only supported socket level.

@code{name} can be one of:

@table @code
@item SO_ACCEPTCONN
@code{val} will point to an @code{uint32_t}. @code{1} will be written there if
the passed socket is listening, and @code{0} if it is not/cannot listen due to
protocol. @code{getsockopt} only.

@item SO_ERROR
@code{val} will point to an @code{uint32_t}. The value will be written with the
present socket error if any, or @code{0} if none are present. @code{getsockopt}
only.

@item SO_SNDBUF
@code{val} will point to an @code{uint32_t}. If getting the value, the current
send-buffer size will be returned, else, it setting it, the passed size will
be used for the same buffer.

@item SO_TYPE
@code{val} will point to an @code{uint32_t}. The type of socket will be
returned in that variable in the same format as @pxref{socket}.
@code{getsockopt} only.

@item SO_PEERCRED
@code{val} points to a struct of three @code{uint32_t} values, the @code{pid},
@code{uid}, and @code{gid} of the peer.

@item SO_PASSCRED
@code{val} is a 32 bit integer value that is zero or one. One when set or
retrieved means that the socket will receive ancillary @code{SCM_CREDENTIALS}
data when receiving messages, if not enabled, no credentials data will be
received even if explicitly sent.
@end table

The syscall returns 0 on success or @code{-1} on failure, with the errno:

@table @code
@item EBADFD
@code{fd} was not open, or is not a socket.

@item EACCES
@code{val} did not point to valid memory.

@item EINVAL
The passed @code{name} or @code{level} were not valid.
@end table

@node gettidid/settidid
@section gettidid/settidid

@example c
int gettidid(int tid, char *id, size_t size);
int settidid(int tid, char *id, size_t size);
@end example

This syscall gets or sets the passed thread's ID. An ID is an array associated
with a thread for debug purposes. A thread is given no ID at creation, and
fetching it will fail. The ID is a C-style string.

These syscalls returns 0 on success or @code{-1} on failure, with the errno:

@table @code
@item EINVAL
The passed buffers were either too big for setting, or to small for fetching
the ID, or the passed thread is not valid.

@item EFAULT
The passed buffers were pointing to invalid memory.
@end table

@node failure_policy
@section failure_policy

@example c
#define OOM_ALLOW_PROC_KILL 1

struct fail_modes @{
    uint64_t placeholder;
@};

int failure_policy(struct fail_modes *old, struct fail_modes *new);
@end example

This syscall fetches and customized kernel behaviour on a series of failure
conditions. @code{old}, if not null, can be used for fetching the values
used at the time of calling, while @code{new}, if not @code{null}, will be used
to set new values.

The values contained by the arguments are ignored, these values are reserved
for future error recovery configuration not implemented right now.

This syscall returns 0 on success or @code{-1} on failure, with the errno:

@table @code
@item EFAULT
The passed buffers were pointing to invalid memory.

@item EACCES
When setting new values with @code{new}, the calling process did not have the
capability @code{MAC_CAP_SYSMAC}.
@end table

@node create_thread
@section create_thread

@example c
int create_thread(void *callback, void *arg, void *stack, void *tls_addr, int cluster);
@end example

This syscall creates a thread for the caller process.

This syscall returns the TID on success or @code{-1} on failure, with the errno:

@table @code
@item EFAULT
The passed buffers were pointing to invalid memory.

@item EACCES
MAC disallowed this.
@end table

@node signal_return
@section signal_return

@example c
int signal_return(void);
@end example

This syscall is to be called to return to normal execution from a signal
handler. Not calling this syscall at the end of handling a signal is very
much undefined behaviour, and will most likely make you regret not doing so.

This syscall does not return in success, and returns @code{-1} on failure, with
the errno:

@table @code
@item EAGAIN
Thread is not handling a signal.
@end table

@node sigaltstack
@section  sigaltstack

@example c
typedef struct @{
    void  *ss_sp;
    size_t ss_size;
    int    ss_flags;
@} stack_t;

int sigaltstack(const stack_t *ss, stack_t *old_ss);
@end example

This syscall allows a thread to define an alternative stack to use for signal
handling. The alternative stack will be only used if @code{sa_sigaction}
requested it by using @code{SA_ONSTACK}.

If @code{old_ss} is not @code{NULL}, the old alternative stack being replaced
is returned there.

If @code{ss} is not @code{NULL}, the alternative stack will be replaced
with the pointed contents.

The @code{ss_flags} field of both old and new values is a bitfield with the
following values:

By default, the alternative stack of every thread at creation points to a
null address, and is disabled.

@table @code
@item SS_ONSTACK
The thread is currently executing on the alternate signal stack.
(Note that it is not possible to change the alternate signal stack if the
thread is currently executing on it).

@item SS_DISABLE
Disable the use of this stack, using this stack with @code{sigaction} will not
result on anything.
@end table

This syscall returns @code{0} on success, and returns @code{-1} on failure,
with the errno:

@table @code
@item EAGAIN
Thread is not handling a signal.
@end table

@node recvsockctr/sendsockctr
@section recvsockctr/sendsockctr

@example c
int recvsockctr(int fd, void *buf, size_t len);
int sendsockctr(int fd, void *buf, size_t len);
@end example

This syscall allows to fetch the control block of a socket referred to by
@code{fd}. If no control data is available, nothing will be written to the
buffer.

This syscall returns @code{0} on success, and returns @code{-1} on failure,
with the errno:

@table @code
@item EBADFD
The passed file was not a socket.
@item EFAULT
The passed buffer points to invalid memory.
@end table

@node listmounts
@section listmounts

@example c
struct mountinfo @{
    uint32_t fs_type;
    uint32_t flags;
    char source[20];
    uint32_t source_len;
    char location[20];
    uint32_t location_len;
    uint64_t block_size;
    uint64_t fragment_size;
    uint64_t size_in_frags;
    uint64_t free_blocks;
    uint64_t free_blocks_user;
    uint64_t inode_count;
    uint64_t free_inodes;
    uint64_t free_inodes_user;
    uint64_t max_filename_len;
@} __attribute__((packed));

size_t listmounts(struct mountinfo *addr, size_t len);
@end example

This syscall writes a list of all mounts currently in use in the system to
@code{addr}, which contains @code{len} items.

The number of mounts in the system is returned in success, and @code{-1} in
failure, with the following errno:

@itemize @bullet
@item
@code{EFAULT}: The array pointed by @code{addr} is outside accessible memory.
@end itemize

@node uname
@section uname

@example c
struct utsname @{
    char system_name[65];
    char node_name[65];
    char release[65];
    char version[65];
    char machine[65];
@} __attribute__((packed));

int uname(struct utsname *addr);
@end example

This syscall writes system information to the passed structure. The strings
on the structure are NUL-terminated.

@itemize @bullet
@item
@code{EFAULT}: The struct pointed to by @code{addr} is not accessible.
@end itemize

@node listthreads
@section listthreads

@example c
struct thread_info @{
    uint16_t thread_id;
    uint16_t niceness;
    uint16_t priority;
    uint16_t pid;
@} __attribute__((packed));

size_t listthreads(struct thread_info *addr, size_t len);
@end example

This syscall writes a list of all threads currently in the system to
@code{addr}, which contains @code{len} items.

The number of threads in the system is returned in success, and @code{-1} in
failure, with the following errno:

@itemize @bullet
@item
@code{EFAULT}: The array pointed by @code{addr} is outside accessible memory.
@end itemize

@node listnetinter
@section listnetinter

@example c
#define NETINTER_BLOCKED 1
struct netinter @{
    char name[65];
    uint64_t flags;
    uint8_t mac_address[6];
    uint8_t ipv4_addr[4];
    uint8_t ipv4_subnet[4];
    uint8_t ipv6_addr[16];
    uint8_t ipv6_subnet[16];
@} __attribute__((packed));

size_t listnetinter(struct thread_info *addr, size_t len);
@end example

This syscall writes a list of all network interfaces currently in the system to
@code{addr}, which contains @code{len} items.

The number of threads in the system is returned in success, and @code{-1} in
failure, with the following errno:

@itemize @bullet
@item
@code{EFAULT}: The array pointed by @code{addr} is outside accessible memory.
@end itemize

@node dumplogs
@section dumplogs

@example c
size_t dumplogs(char *buffer, size_t len);
@end example

This syscall writes the kernel logs to a buffer in memory.

The buffer takes the form of a string in memory of, every log line in the
buffer takes exactly 80 characters separated by no newlines or other special
characters, thus the user needs to split it themselves for printing.

The length of the buffer is returned in success, and @code{-1} in failure, with
the following errno:

@itemize @bullet
@item
@code{EFAULT}: The array pointed by @code{addr} is outside accessible memory.
@end itemize

@node listflocks
@section listflocks

@example c
struct flock_info @{
    uint32_t pid;
    uint32_t mode;
    uint64_t start;
    uint64_t length;
    uint64_t fs;
    uint64_t ino;
@} __attribute__((packed));

size_t listflocks(struct flock_info *addr, size_t len);
@end example

This syscall writes a list of all POSIX file locks currently in use set with
@code{fcntl} to @code{addr}, which contains @code{len} items.

The number of file locks is returned in success, and @code{-1} in
failure, with the following errno:

@itemize @bullet
@item
@code{EFAULT}: The array pointed by @code{addr} is outside accessible memory.
@end itemize

@node loadavg
@section loadavg

@example c
int loadavg(uint32_t *buf, size_t len);
@end example

This syscall writes average load values to the passed buffer of @code{len}
items

The average values represent the number of processes executed by the system
over various periods of time. Ironclad only implements the first three
intervals, which represent the average for 1, 5, and 15 minutes respectively.

The number of average values written is returned in success, and @code{-1} in
failure, with the following errno:

@itemize @bullet
@item
@code{EFAULT}: The array pointed by @code{buf} is outside accessible memory.
@end itemize

@node meminfo
@section meminfo

@example c
struct meminfo @{
    uint64_t phys_total;
    uint64_t phys_avail;
    uint64_t phys_free;
    uint64_t shared_usage;
    uint64_t kernel_usage;
    uint64_t table_usage;
    uint64_t poison_usage;
@} __attribute__((packed));

int meminfo(struct meminfo *addr);
@end example

This syscall writes memory usage information to the passed structure.

The values stand for:

@itemize @bullet
@item
@code{phys_total}: Total physical memory present in the system.
@item
@code{phys_avail}: Total physical memory available for OS use in the system.
@item
@code{phys_free}: Of the available physical memory, how much is not used.
@item
@code{shared_usage}: Memory used in shared memory segments.
@item
@code{kernel_usage}: Memory used by the kernel.
@item
@code{table_usage}: Memory used in the effort of keeping track of memory.
@item
@code{poison_usage}: Physical memory denied by memory poisoning, and other
error-correcting and mitigating measures.
@end itemize

The syscall returns @code{0} on success or @code{-1} on failure, with the
following errno:

@itemize @bullet
@item
@code{EFAULT}: The struct pointed to by @code{addr} is not accessible.
@end itemize

@node listpci
@section listpci

@example c
struct pci_info @{
    uint8_t bus;
    uint8_t func;
    uint8_t slot;
    uint16_t device_id;
    uint16_t vendor_id;
    uint8_t rev_id;
    uint8_t subclass;
    uint8_t device_class;
    uint8_t prog_if;
@} __attribute__((packed));

size_t listpci(struct pci_info *addr, size_t len);
@end example

This syscall writes a list of all detected PCI devices in the system alongside
their identification information to the buffer contained at @code{addr}, which
contains @code{len} items.

The numbers returned for device and vendor IDs can be translated to human
readable strings by the use of a PCI database, like
@uref{https://pci-ids.ucw.cz/, The PCI ID Repository}, distributed and
maintained kindly by Albert Pool and @uref{http://mj.ucw.cz/, Martin Mares}.

The number of detected PCI devices is returned in success, and @code{-1} in
failure, with the following errno:

@itemize @bullet
@item
@code{EFAULT}: The array pointed by @code{addr} is outside accessible memory.
@end itemize

@node getcpuinfo
@section getcpuinfo

@example c
struct cpuinfo @{
    uint64_t conf_count;  // Cores physically present in the system.
    uint64_t onln_count;  // Logical cores being used by the OS.
    char model_name[64];  // 0-padded
    char vendor_name[64]; // 0-padded
    uint32_t base_mhz;    // Base frequency in MHz.
    uint32_t max_mhz;     // Max frequency in MHz.
    uint32_t ref_mhz;     // Reference frequency in MHz.
@};

int getcpuinfo(struct cpuinfo *info);
@end example

This syscall gets information about the CPU or CPUs running on the system.

This information is purely for user-facing purposes, and no consistency on the
results is ensured or to be expected. This syscall just returns system
information for pretty printing.

This syscall returns @code{0} on success and @code{-1} on failure, with errno:
@table @code
@item EFAULT
The passed buffers were pointing to invalid memory.
@end table

@node socketpair
@section socketpair

@example c
int socketpair(int domain, int type, int *fds);
@end example

This syscall creates a pair of interconnected sockets, that are otherwise
identical, and returns their FDs on @code{fds[0]} and @code{fds[1]}. The
arguments are the same as the parent @code{socket} syscall.

This syscall returns @code{0} on success and @code{-1} on failure, and shares
errnos with the main @code{socket} syscall.

@node madvise
@section madvise

@example c
#define POSIX_MADV_NORMAL     1
#define POSIX_MADV_SEQUENTIAL 2
#define POSIX_MADV_RANDOM     3
#define POSIX_MADV_DONTNEED   4
#define POSIX_MADV_WILLNEED   5

int madvise(void *addr, size_t len, int advice);
@end example

This syscall gives a hint to the operating system on how the user plans to use
the memory range. No access information is changed, this is just a hint for
the operating system to do stuff with.

@code{advice} can be one of:
@table @code
@item POSIX_MADV_NORMAL
Average access. The equivalent of not advising anything.

@item POSIX_MADV_SEQUENTIAL
Memory will be accessed sequentially from bottom to top.

@item POSIX_MADV_RANDOM
Memory will be accessed with no real pattern, all over the place.

@item POSIX_MADV_DONTNEED
This memory range is not needed anymore.

@item POSIX_MADV_WILLNEED
This memory range will be needed shortly.
@end table

This syscall returns @code{0} on success and @code{-1} on failure, with errno:
@table @code
@item EFAULT
The passed buffers were pointing to invalid memory.
@end table

@node nvmm_capability
@section nvmm_capability

@example c
struct nvmm_caps @{
    uint32_t version;
    uint32_t state_size;
    uint32_t max_machines;
    uint32_t max_vcpus;
    uint64_t max_ram;
@};

int nvmm_capability(struct nvmm_caps *caps);
@end example

This syscall fetches details about the NVMM implementation that the kernel
exposes to userland. @code{version} is always 2 for Ironclad, but should be
checked as to future proof/portability.

This syscall returns @code{0} on success or @code{-1} on failure, with the
errno:

@table @code
@item EFAULT
The passed buffers were pointing to invalid memory.
@item ENOTSUPP
The current configuration doesn't support NVMM.
@end table

@node nvmm_machine_create
@section nvmm_machine_create

TBD

@node nvmm_machine_destroy
@section nvmm_machine_destroy

TBD

@node nvmm_machine_configure
@section nvmm_machine_configure

TBD

@node nvmm_vcpu_create
@section nvmm_vcpu_create

TBD

@node nvmm_vcpu_destroy
@section nvmm_vcpu_destroy

TBD

@node nvmm_vcpu_configure
@section nvmm_vcpu_configure

TBD

@node nvmm_vcpu_setstate
@section nvmm_vcpu_setstate

TBD

@node nvmm_vcpu_getstate
@section nvmm_vcpu_getstate

TBD

@node nvmm_vcpu_inject
@section nvmm_vcpu_inject

TBD

@node nvmm_vcpu_run
@section nvmm_vcpu_run

TBD

@node nvmm_gpa_map
@section nvmm_gpa_map

TBD

@node nvmm_gpa_unmap
@section nvmm_gpa_unmap

TBD

@node nvmm_hva_map
@section nvmm_hva_map

TBD

@node nvmm_hva_unmap
@section nvmm_hva_unmap

TBD

@node nvmm_gva_2_gpa
@section nvmm_gva_2_gpa

TBD

@node nvmm_gpa_2_hva
@section nvmm_gpa_2_hva

TBD

@node nvmm_assist_io
@section nvmm_assist_io

TBD

@node nvmm_assist_mem
@section nvmm_assist_mem

TBD

@node nvmm_vcpu_dump
@section nvmm_vcpu_dump

TBD

@node nvmm_vcpu_stop
@section nvmm_vcpu_stop

TBD

@node pci_read/pci_write
@section pci_read/pci_write

@example c
ssize_t pci_read(uint8_t bus, uint8_t slot, uint8_t func, void *buffer, size_t count, size_t offset);
ssize_t pci_write(uint8_t bus, uint8_t slot, uint8_t func, void *buffer, size_t count, size_t offset);
@end example

These syscalls attempts to read or write to and from the configuration space
of a PCI device. All of the operations are blocking.

These syscalls returns the number of bytes operated on, or @code{-1} on
failure. errno is to be set to:

@itemize @bullet
@item
@code{EFAULT}: The passed buffer is not accessible.

@item
@code{EINVAL}: The passed device coordinates dont relate to a device.
@end itemize

@node Networking
@chapter Networking

This chapter gives all the details on how Ironclad handles networking.

@node Layering
@section Layering

The OSI model, as per the X.200 recommendation, defines 7 layers:

@example
| No. | Layer Name   | Example technologies                 |
| +++ | ++++++++++++ | ++++++++++++++++++++++++++++++++++++ |
| 7   | Application  | WebSocket, HL7                       |
| 6   | Presentation | Idk I do embedded, weird stuff here  |
| 5   | Session      | Sockets, Named pipes, NetBIOS (eek!) |
| 4   | Transport    | TCP, UDP, NBF                        |
| 3   | Network      | IP, IPSec, ICMP                      |
| 2   | Data link    | ARP, NDP, MAC                        |
| 1   | Physical     | Ethernet, WiFi, Bluetooth            |
@end example

Ironclad aims to provide all the way to the @strong{session} layer, no more!
(and no less). The main interface for networking used to interface with that
layer will be the socket. For learning about sockets, @ref{socket}.

@node Interface handling
@section Interface handling

Ironclad registers one interface per valid device plus one for a loopback
device. New addresses cannot be added manually, they may only be added and
removde by the kernel. Some parameters are available for user control though,
including per-interface configuration and enabling and disabling.

All interfaces but @code{loopback} will be disabled by default, that is, they
will be setup and ready to go, but will refuse connectivity via kernel block,
as a security measure to avoid unexpected connectivity. They will need manual
enabling.

@node Loopback
@section Loopback

The loopback device is a special, virtual network interface meant to be used
mainly for diagnostics and troubleshooting, along for enabling connecting to
servers running on the local machine.

It works fundamentally by returning the packets sent to it (loopback!), in such
a way that services can talk with themselves. This device implements no
physical layer of the network stack, packets are passed without that layer.

Loopback will always have the static IP addresses @code{127.0.0.1/8} and
@code{::1/128}. These addresses can be changed in runtime.
@ref{config_netinter}.

@node Virtualization
@chapter Virtualization

This chapter gives all the details about Ironclad's NVMM support, which is how
Ironclad provides accelerated hardware virtualization.

@node NetBSD Virtual Machine Monitor (NVMM)
@section NetBSD Virtual Machine Monitor (NVMM)

NVMM is a full type-2 hypervisor solution for NetBSD on several architectures,
Ironclad implements it as a cleaner, more lightweight version of something like
Linux's @url{https://docs.kernel.org/virt/kvm/api.html, KVM}. DragonFlyBSD
hosts guides on using it
@url{https://www.dragonflybsd.org/docs/docs/howtos/nvmm/, here}.

NVMM usually gets exposed in the way of a library, like @code{libnvmm},
Ironclad only provides the building blocks of said library in the form of
syscalls.

@node Differences with NetBSD
@section Differences with NetBSD

Ironclad only provides the non-IOCTL interfaces, using syscalls only. No
@code{/dev/nvmm} is provided either. To check presence, @code{nvmm_capability}
will fail with @code{ENOTSUPP} if there is no NVMM support.

@node Filesystem support and interfaces
@chapter Filesystem support and interfaces

@node Generic filesystem options
@section Generic filesystem options

@subsection @code{relatime} and @code{noatime}

Filesystems usually feature access, creation, and modification time tracking
for their folders and files. These times are updated by the operating system,
and later written to disk, increasing disk access.

Modification and creation times are no big deal, but access times can carry a
strong performance penalty, given read-only access is access. These access time
updates can, over time, lead to missed performance on the table, and shorter
lifespans for drives.

In order to mitigate this, Ironclad allows filesystems to be mounted
@code{relatime} and @code{noatime}. @code{relatime} will make it so access
times are only updated if the modify time is greater, making it so only one
access post-modification is tracked. @code{noatime} will not update access
times at all.

These flags can be applied on mount. @ref{mount/umount}.

@node EXTended filesystem (EXT)
@section EXTended filesystem (EXT)

Ironclad supports EXT-series filesystems read-only and read-write.

While a user may be used to the ext2/3/4 distinction, EXT internally works as
an independent set of features, with the version numbers specifying a
widely understood, assumed, and inconsistent set of features.

Ironclad supports the feature list: @code{sparse_super}, @code{large_file},
@code{filetype}, @code{resize_inode}, @code{dir_index}, @code{ext_attr}.

Those features should translate to ext2 read-write support, and ext3 read-only
support.

Some @code{ioctl} calls exist for files inside EXT-series FSs, which can help
manage specialized FS-specific inode flags and permissions, they are:

@example c
EXT_GETFLAGS = 0x5600
EXT_SETFLAGS = 0x5601

ioctl(fd, EXT_GETFLAGS, pointer_to_u32); // Get EXT's flags inode field.
ioctl(fd, EXT_SETFLAGS, pointer_to_u32); // Set EXT's flags inode field.
@end example

@subsection Ironclad support quirks

EXT features a error policy on EXT internal errors that dictates for the kernel
to panic when triggered. While other operating systems honor the policy as-is,
Ironclad deliberately acts on it was a "Remount read only" policy. This is done
to avoid denial of service attacks by mounting deliberately faulty flesystems.

@node File Allocation Table (FAT)
@section File Allocation Table (FAT)

Ironclad's FAT support is really rough. Only read-only FAT32 is supported.
No special @code{ioctl} calls are provided. Long filenames are not supported.

@node Devices and their properties
@chapter Devices and their properties

Ironclad exposes a number of physical and virtual devices to userland. All
of them are exposed under the @code{/dev} location, and support a series of
standard operations, like being manipulated by the usual file-related
syscalls like @code{read} or @code{write}, while sporting device-specific
interfaces in the form of device-specific @code{ioctl} requests.

When querying device-specific information, Ironclad exposes information a bit
different than other kernels like Linux. Here is a quick list of the most
notable differences:

@itemize @bullet
@item
The @code{BLKGETSIZE}/@code{BLKGETSIZE64} @code{ioctl} calls are not available,
instead, the block count and block size values of @code{stat} are used.
@end itemize

All devices in Ironclad have the @code{ioctl} call @code{DEV_PARTUUID}
implemented, with the signature:

@example c
#define DEV_PARTUUID 0x9821

ioctl(fd, DEV_PARTUUID, &pointer_to_uuid); -- uuids being uint8_t[16];
@end example

This call will write the UUID of the device pointed to by @code{fd}. If
all zeros, will mean that the device has no associated UUID. This UUID is the
UUID of the partition, not of the FS, like, for example, the GPT's partition
UUID.

@node Common devices
@section Common devices

These are devices exposed in Ironclad regardless of target system when
present, with standardized interfaces.

@subsection console

@code{/dev/console} wraps architecture-specific debug output channels for use
with file operations. For x86-based targets, this is COM1, for other targets,
this may be UART.

If the target implements reading from the debug channels, read will be
supported as well. If not implemented, the device will be read-only.

The kernel also uses the debug channels for output, so keep in mind the
contentions that can cause. If you are doing a lot of spaced writes, do not
be surprised if the kernel pops in the middle! In the other hand, the kernel
does not read from the debug channels.

@subsection loopback

@code{/dev/loopback} is the network loopback device, explained on
@ref{Loopback}.

@subsection ramdev

The devices starting by @code{ramdev} are virtual devices representing the
RAM driver passed by some boot protocols, an FS can be mounted to them, or be
otherwise used like any other block device. These RAM devices are read/write,
but they cannot grow in size, so changes are constrained to the area the
RAM device already has allocated.

@subsection random/urandom

The device @code{random} is equivalent to the one featured in other UNIX-like
kernels, and can be read to get a stream of cryptographically secure
pseudo-random bytes. It is implemented using a Fortuna-like PRNG, and does
not block when waiting for new entropy.

@code{random} allows for writing as well, which will take random data for
mixing into the kernel's entropy pools.

Ironclad does not go out of its way to feed user-accessible discrete randomness
sources to the kernel's entropy pools, like a hardware RNG, or x86's
@code{rdrand}. It is highly recommended to use userland daemons to periodically
feed the kernel entropy with these kind of sources by writing to @code{random}.
This can also be used to implement seed files, for example:

@example sh
# On boot, maybe as part of the init system.
cat seedfile.bin > /dev/random

# On poweroff.
dd if=/dev/random of=seedfile.bin bs=4M count=1 iflag=fullblock
@end example

@code{/dev/urandom} does the same as @code{/dev/random}, and is only provided
as a virtual alias for compatibility.

@code{getentropy} is provided as well for avoiding the file interface when
interfacing with @code{random}, as that may avoid certain kinds of DoS
attacks related to opened file limits.

@subsection null/zero

@code{null} returns @code{EOF} whenever read, and all the write operations are
discarded.

@code{zero} returns exclusively a stream of zeros when read, and all write
operations are discarded.

@subsection i6300esb

@code{i6300esb} is a hardware watchdog featured in a lot of intel hardware, it
can be reset by using @code{write} and can be configured using
@code{ioctl} like:

@example c
WDOG_START     = 1 // Start the count.
WDOG_STOP      = 2 // Stop the count.
WDOG_HEARTBEAT = 3 // Reset and set a new heartbeat period in seconds.

ioctl(wdog, WDOG_START, ignored); // Enable 2:1 scaling.
ioctl(wdog, WDOG_STOP,  ignored); // Enable 1:1 scaling.
ioctl(wdog, WDOG_HEARTBEAT, pointer_to_uint32_t);
@end example

There is no default heartbeat count, so be sure to configure it if you do not
want mayhem. Access to reset and configuration can be restricted by using
MAC.

While this piece of hardware allows for hooking up interrupts and reboot
separately when the timer expires, Ironclad right now will only reboot when
the timer expires.

@subsection sata

The devices starting by @code{sata} represent several SATA AHCI block devices.
For now only SATA drives are supported, support for ATAPI is not present.

These SATA drives have internal caching at the driver level, so they must be
@code{sync}'d for data integrity when wanting to ensure data coherency.

@subsection  nvme

The devices starting by @code{nvme} represent NVMe block devices, namespaces
are named using @code{n} followed by the namespace number.

NVMe drives have internal caching at the driver level, so they must be
@code{sync}'d for data integrity when wanting to ensure data coherency.

@subsection pwrbutton/sleepbutton

These devices are provided only by platforms implementing power and sleep
buttons. Programs can @code{poll} on them for read permission. When the
corresponding device reports being able to read, it shall be interpreted as a
oneshot event representing a pressing of the corresponding button.

@subsection virtio-block

These devices represent virtio block devices, usually provided by hypervisors
like QEMU. They support read/write operations, and must be @code{sync}'d for
data integrity when wanting to ensure data coherency. Ironclad only supports
modern PCI transport, and does not bother supporting legacy or transitional
devices.

These devices are named @code{vdisk} followed by a number, starting at 0.

To launch qemu with a virtio block device, use something like:

@example sh
qemu-system-x86_64 -device virtio-blk-pci,drive=boot,disable-legacy=on -drive id=boot,file=gloire.img,format=raw,if=none
@end example

@node riscv64-limine devices
@section riscv64-limine devices

@subsection fb[0..x]

The @code{fb} series devices, like @code{fb0} and @code{fb1}, expose the
framebuffer passed as part of the boot protocol, when present. The device uses
Linux's @url{https://docs.kernel.org/fb/api.html, fbdev} interface.

@node x86_64-limine devices
@section x86_64-limine devices

@subsection fb[0..x]

The @code{fb} series devices, like @code{fb0} and @code{fb1}, expose the
framebuffer passed as part of the boot protocol, when present. The device uses
Linux's @url{https://docs.kernel.org/fb/api.html, fbdev} interface.

@subsection ps2keyboard/ps2mouse

The devices @code{ps2keyboard} and @code{ps2mouse} exposes x86's native PS2
interfaces, @code{ps2keyboard} is a normal character device that returns
scancodes as they are received. @code{ps2mouse} is a character device that
returns mouse packets following the structure:

@example c
struct mouse_data @{
   int x_variation;
   int y_variation;
   int z_variation;
   bool is_left_click;
   bool is_right_click;
   bool is_middle_clock;
   bool is_4th_click;
   bool is_5th_click;
@};
@end example

@code{ps2mouse} supports a series of @code{ioctl} calls for setting different
modes and talking directly with the PS2 controller:

@example c
PS2MOUSE_2_1_SCALING     = 1
PS2MOUSE_1_1_SCALING     = 2
PS2MOUSE_SET_RES         = 3
PS2MOUSE_SET_SAMPLE_RATE = 4

ioctl(mouse, PS2MOUSE_2_1_SCALING, ignored);  // Enable 2:1 scaling.
ioctl(mouse, PS2MOUSE_1_1_SCALING, ignored);  // Enable 1:1 scaling.
ioctl(mouse, PS2MOUSE_SET_RES, resolution);   // (0 - 3).
ioctl(mouse, PS2MOUSE_SET_SAMPLE_RATE, rate); // (0 - 200).
@end example

Valid resolutions and sample rates are values for the PS2 controller, else
the call is ignored. For valid values and their meaning refer to
@uref{https://isdaman.com/alsos/hardware/mouse/ps2interface.htm, this website}.

@subsection serial

The devices starting by @code{serial} represent the several character devices
used for each present serial port, they support read/write operations, but no
TTY interface is exposed, they are raw byte streams.

Baud and other settings can be set by using the @code{termios}, note that
most of the fields are not implemented as the serial devices are not ttys but
just byte streams.

The default baud for all ports is set to be @code{115200}.

@node GNU Free Documentation License
@appendix GNU Free Documentation License
@include fdl.texi

@bye
